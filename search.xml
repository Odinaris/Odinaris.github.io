<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JPEG隐写术之UED]]></title>
    <url>%2F2019%2F07%2F01%2FJPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BUED%2F</url>
    <content type="text"><![CDATA[本文介绍了JPEG隐写术中的UED算法。首先介绍了JPEG的统计特性与隐写分析之间的关系，然后介绍了nsF5算法的修改策略，从而引出均匀嵌入（Uniform Embedding）策略的思想并给出了均匀嵌入失真（Uniform Embedding Distortion）函数的公式。 参考论文 Title Authors Uniform Embedding for Efficient JPEG Steganography Linjie Guo, Jiangqun Ni, and Yun Qing Shi JPEG统计特征隐写分析中通常使用量化后的DCT系数来构建特征集合，用以检测JPEG隐写术。实际上，块DCT系数中的直方图和共生矩阵被广泛使用在隐写分析中。直方图对应的是一阶统计，共生矩阵对应的是二阶统计（可以捕获DCT系数之间的相关性）。 一旦有秘密信息被嵌入到JPEG图像中，DCT系数的统计就会有一定程度的修改，这就给隐写分析留下了踪迹。 图1是JPEG原始DCT系数的直方图和共生矩阵。其中共生矩阵中的X2是X1的相邻系数，移动步长为1。可以看出，绝大部分系数都集中在0以及0附近。 可以认为DCT系数的一阶统计特征是类拉普拉斯分布的，这个事实需要注意。 nsF5的嵌入变化 图2是DCT系数使用nsF5算法进行嵌入之后得到的修改后的直方图，可以看到基本上0系数已经移动到左右两边了。图3是对这些修改的统计，可以看出在0系数以及附近的修改所占比重明显。空间有限，这里就不展示共生矩阵的嵌入变化了，但基本上是与一阶统计特性相似的。 nsF5是如何修改的？想要理解为什么nsF5嵌入修改之后会造成上文所述的变化，就要先了解nsF5的工作流程。 对于给定载荷\alpha，nsF5的具体工作流程如下： 根据\alpha计算嵌入效率的理论界限; 计算需要被修改的系数个数n； 随机选择n个非零AC系数并将他们的绝对值减1. 上文提到，DCT系数的分布是类拉普拉斯分布的，而nsF5所采用的随机选择策略，会导致大部分被修改的系数都是绝对值小的系数。也就是图中所展示的，大部分修改后的系数集中在绝对值2以内。 何为均匀嵌入（Uniform Embedding）？通过利用DCT系数的统计分布特征（类拉普拉斯分布），大部分隐写分析检测JPEG隐写术都可以获得高准确率。对于JPEG隐写术来说，即使采用一种更为有效的编码策略来使得总的系数修改数降低，嵌入后的修改系数分布特征还是相似的。这样还是会很容易被隐写分析者检测出来。 这时，均匀嵌入策略就异军突起，走向历史舞台了。 UE策略试图将对系数的嵌入修改扩展到所有存在的系数中去来最小化每个bin（直方图中，列可以叫做bin）的统计变化。这类似于扩频通信（spread specturm）的思想，关于扩频通信，我学通信的朋友生动地给我手绘了一张图来说明： 这是意识流的解释，懂的自然懂（滑稽）。 均匀嵌入失真函数（UED）的设计思想为了能够完成均匀嵌入，使用到的失真函数必须设计成不同大小的系数都能够以相同的优先级被选择到。这个失真函数就称作是均匀嵌入失真函数（Uniform Embedding Distortion）。 用x表示具有类拉普拉斯分布特征的DCT系数，那么UED使用到的失真函数应该具有下面这种i形式： \rho(x)=1/|x|即，系数x被选择的概率随着x的绝对值增大而减小，成反比。 图4绘制了上述介绍的分布的大致曲线，a是DCT系数的分布，b就是UED每个系数被选择的概率分布，c就是被选择的系数分布的大致曲线。 对自然图像模型的参考很明显看出，使用UED来设计失真时，对绝对值大的DCT系数的修改数量是高于之前提出的方法的。 现有的JPEG隐写分析方法一般会利用自然图像模型的优势，即根据量化后DCT系数的一阶和二阶统计特性来进行隐写分析。 如果某种图像模型可以准确的表示DCT系数的分布状况（我的理解是能够对分布情况提出合理的量化表述），那么对载体进行任何轻微的修改都会被检测出来。 幸运的是，对于自然图像来说，DCT系数的分布严重依赖图像内容，每种内容不同的图像的分布特征都有明显差别。也就是说自然图像的统计特征没有任何一种图像模型可以准确估计出来。这对于隐写术来说，无疑是件好事。 为了证明自然图像在一阶和二阶统计上的偏差，作者首先计算直方图$p(x)$的均值$\mu(x)$和标准差$\sigma(x)$。然后用归一化变异系数（coefficient of variation）来定义标准差和均值的比： Cv(x)=\frac {\sigma(x)} {\mu(x)}这里就体现了用相对变化来衡量失真的作用，因为无论用均值和标准差来独自证明检测能力随系数值的变化，都是不合理的。 篇幅限制，这些量随系数绝对值增大的变化这里不作展示，只陈述结果。 作者发现，$Cv(x)$随着$x$的绝对值增加而增加，这说明随着$x$的绝对值增加，DCT系数直方图偏差严重 ，这句十分不理解，但结合论文中对二阶统计的介绍，是说随着系数增大，更难以去建模统计特征，也就是抗隐写分析的能力更好吧（存疑）。 根据这个结论，如果使每个$x$的相对修改率与它自身的$Cv$值成比例的话，就可以使得对所有x做出均匀的修改，并且一阶统计特性的统计影响也能最小化。在二阶统计上也观察到了相似的效果。因此，修改一个DCT系数，在统计上的影响依赖于系数本身大小以及和它相邻的系数大小。 均匀嵌入失真函数的设计 基于单系数的均匀嵌入失真（SC-UED） 用$c_{ij}$表示在$(i,j)$位置上的DCT系数，SC-UED可以设计如下： \rho_{ij}^{SC}=|c_{ij}|^{-1}.没错，就是上面提到的失真函数设计思想中的一般形式。 基于联合系数的均匀嵌入失真（JC-UED） 设计更加实用的UED，不知需要考虑到DCT系数自身大小，它的块间和块内相邻的系数都需要被考虑在内。作者认为块内和块间相邻系数有着最强的数值相关性。将多个系数同时考虑在内的失真函数就是基于联合系数的均匀嵌入失真（JC-UED）： \rho_{ij}^{JC}=\sum_{d_{ia} \in N_{ia}}(|c_{ij}|+|d_{ia}|+a_{ia})^{-1}+\sum_{d_{ir} \in N_{ir}}(|c_{ij}|+|d_{ir}|+a_{ir})^{-1}.其中$N_{ia}=\{c_{i+1,j},c_{i-1,j},c_{i,j+1},c_{i,j-1}\}$和$N_{ir}=\{c_{i+8j},c_{i-8,j},c_{i,j+8},c_{i,j-8}\}$分别表示块内相邻系数和块间相邻系数。$a_{ia}$和$a_{ir}$是调节参数，具体值可根据实验确定。 对UED的总结因为以往的JPEG隐写术，如nsF5算法对于DCT系数的修改大都集中在零AC系数附近，这是由DCT系数的类拉普拉斯分布及随机选择策略决定的。为了减少这种明显的隐写嵌入特征，作者提出了均匀嵌入策略，试图将修改平均分布到所有系数中，从而最小化失真，导致更低的统计可检测性，提高隐写术的安全性。在UE的思想下，作者设计了两种失真函数，SC-UED和JC-UED，其中JC-UED能够同时兼顾一阶和二阶统计特性，起到很好的均匀嵌入效果。 疑问图3的数据分布我目前不知道作何解释，论文里说的是使用nsF5得到的数据相对于原图再统计上的变化。可能是我哪里理解不到位吗？这里先占个坑，后续确认理解无误再进行说明。]]></content>
      <categories>
        <category>Steganography</category>
      </categories>
      <tags>
        <tag>Steganography</tag>
        <tag>UED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Time]]></title>
    <url>%2F2019%2F06%2F30%2FAbout-Time%2F</url>
    <content type="text"><![CDATA[前言《About Time》，是我最喜欢的一部电影。到现在，已经看了五遍不止，适逢近日倍感孤独，于是今晚又再次打开它，重温主人公给我带来的温暖美好。 First Meeting 初初见你，人群中独自美丽。 蒂姆与玛丽初次从漆黑的酒吧里出来，第一次见面匆匆留下联系方式之后，女主灿然回眸。 First Night 一次次重温着今晚的我和你，是因为我真的很爱你。 蒂姆将玛丽从无聊如地狱的派对中解救出来，两人在餐厅开怀畅聊，之后玛丽忐忑而勇敢地将蒂姆“骗”到了自己家中。 Wedding Planning 我相信婚姻不是坟墓，而是恋人感情的升华。 玛丽和蒂姆就婚礼规划上约定蒂姆定好一件事就脱一件衣服。没想到蒂姆确定了伴郎之后又反悔，真是狡猾~玛丽可不能吃亏！ Our Wedding 我希望我的婚礼是这样的：有你，有我，不要许多人，只要你我眼里满满的都是彼此。 《II Mondo》响起，门缓缓打开，玛丽身着红裙，笑靥如花，款步走来，幸福与爱意洋溢于脸上。 蒂姆与玛丽的婚礼风雨交加，但他们仍然在狂风中亲吻，很是触动。 即使天公不作美，但只要是和你，也无风雨也无晴。 玛丽丝毫不在意婚礼上的恶劣天气，反而对今后的生活充满期待，“Fun!” True Love 真爱，是爱你的一切，真正地关心你的一切。 蒂姆与玛丽两人日夜看守在凯蒂床前，直到她能够认识到自己需要做出改变。 玛丽的笑容，真的很治愈，很美好。 Past &amp; Future 你的笑，给了我直面过去的勇气。 玛丽说要再生一个孩子，这样就可以当只有一个聪明孩子时，剩下两个还可以是快乐的小笨蛋 :)纠结于将逝的父亲与新生的孩子，看到这可爱的笑容，蒂姆怎能反对。 Time Never Stop Thanks, Dad. 父亲带蒂姆又回到了小时候，两人一起在海边散步，打水漂。这是他们最后能在一起相处了。都很开心。 结语 We’re all travelling through time together every day of our lives. All we can do is do our best to relish this remarkable ride. 电影结束了，我的人生还有很长很长。我很喜欢这部电影，不止是羡慕憧憬里面的爱情，还感谢这部电影对我心灵的治愈。每次看完这部电影，孤独啊，烦躁啊，伤感啊，都会统统滚到一边去。因为它让我知道，这些，都是我的一生。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题优化配置记录]]></title>
    <url>%2F2019%2F06%2F28%2Fhexo%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近在网上查询了很多关于如何优化配置Hexo主题的博客，对自己的博客进行了各种各样的探索。猛然发现如果不记录自己做了哪些修改，以后可能都不知道如何怎样关闭/删除/更新。故把自己使用到的配置和参考的博客记录下来。 为next主题的主页文章添加阴影效果为next主题的主页文章添加阴影效果 NexT主题添加搜索功能hexo - Next 主题添加搜索功能 修改nexT主题文章页面宽度修改hexo博客next主题文章页面宽度 修改文章背景颜色themes\next\source\css\_custom\custom.styl下 themes\next\source\css\_custom\custom.styl1234.main-inner &#123; background: #fff; opacity: 0.9;&#125; 修改文章字体颜色themes\next\source\css\_custom\custom.styl下 1234.post-body &#123; /* 字体颜色 */ color: #000;&#125; 自定义样式参考next爬坑深度魔改 首页摘要图片在网上查了很多博客，很多都是先通过hexo-asset-image建立跟文章同名文件夹之后，在文件夹里添加图片。 然后在frontmatter里添加image:url，其中url就是图像的相对路径，文章名+图像名。 但是我试了并没有效果，查看源码发现src中的图像路径差别很大。于是又试了另一种方法，将图像放到统一的images文件夹中，然后frontmatter里就写成image:/images/imagename.jpg的格式，最终成功了。 虽然这种方法可以用，但是因为所有文章图片都放在了同一个文件夹，所以相对管理起来更麻烦一些。 HEXO支持手写流程图暂时不打算添加这个功能，因为不需要，不过先在这里记录一下。 如何让你的HEXO博客支持手写流程图？ 字数统计昨天查了一些字数统计的博客，因为时间都是18年以前的，之前的方法都失效了。 今天又查了一些博客，现把目前可行的方法记录如下。 首先安装hexo-symbols-count-time包： 1$ npm install hexo-symbols-count-time -save 然后在博客配置文件_config.yml中添加 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 最后在nexT配置文件_config.yml中添加 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 这样就可以显示出字数统计和预估阅读时长了。但是字数统计不准确，等之后再考虑优化吧~ Hexo 中 MathJax 的静态显示（svg） 因为我的博客以后大部分用来记录科研方面的文章，会经常用到数学公式。之前使用的mathjax虽然能够正常显示，但每次都要动态加载，渲染需要好几秒时间，总觉得阅读体验不够流畅，于是在网上找到了下面这篇文章： Hexo 中 MathJax 的静态显示（svg） 但是按照这篇文章来更改的时候，发现还是存在一些小问题，所以把完整流程以及需要注意的地方记录如下： 1）安装 在博客根目录~/blog/下 12npm i -g gulp@4.0.2npm i -S gulp@4.0.2 gulp-mathjax-page 这里需要注意一下，因为gulp版本是迭代更新的，我现在更新这篇文章时版本已经更新到了4.0.2，而我参考的这篇文章当时是3.9.1，如果用的是旧版本，npm会提示当前版本已弃用，所以这里安装gulp的时候需要根据自己当时的最新版本来更新版本。 版本查询网址：https://www.npmjs.com/package/gulp 2）新建 在博客根目录~/blog/下建立js文件gulpfile.js，添加内容如下： 123456789101112131415161718192021222324252627282930313233343536373839var gulp = require('gulp')var mathjax = require('gulp-mathjax-page')// gulp.task('mathjax', function() &#123;// gulp.src('./public/**/*.html')// .pipe(mathjax(&#123;// mjpageConfig: &#123;// format: ['TeX'],// singleDollars: true,// cssInline: false,// mhchem: &#123;legacy: true&#125;// &#125;,// mjnodeConfig: &#123;// svg: true,// css: false,// speakText: false// &#125;// &#125;))// .pipe(gulp.dest('./public'))// &#125;)gulp.task('mathjax', done =&gt; &#123; gulp.src('./public/**/*.html') .pipe(mathjax(&#123; mjpageConfig: &#123; format: ['TeX'], singleDollars: true, cssInline: false, mhchem: &#123;legacy: true&#125; &#125;, mjnodeConfig: &#123; svg: true, css: false, speakText: false &#125; &#125;)) .pipe(gulp.dest('./public')) done();&#125;); 这里还存在一个问题，上面注释的内容是我参考的文章中给的代码，但是在使用的时候npm会提示错误： 我把错误提示在Google上搜了一下，在StackOverflow上看到有人也有同样的错误，根据问题下面给出的解决方案，把代码修改成了上面的形式，然后就可以正常使用了。上面代码中注释部分可以删除，这里只是为了展示错误的样例。 3）样式定制 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 12345678910111213.mjpage__block &#123; display: inline-block; text-align: center; width: 100%; overflow-x: auto; vertical-align: bottom;&#125;/*如果出现尺寸过大的问题，则加上以下代码*/.mjpage &#123; font-size: 10px;&#125; 4）使用 1hexo clean &amp;&amp; hexo g &amp;&amp; gulp mathjax &amp;&amp; hexo d 本地无法在浏览器直接hexo s查看预览，但可以gulp mathjax后去 public 文件夹下找到相应文件并用浏览器打开预览。当然，这样预览过于麻烦了，所以建议直接用 Mathjax 官网的 Live Demo 预览，部署前再用上面这种方法确认一遍即可。 这里注意一下，每次生成页面时都要输入gulp mathjax,不然下一次渲染还是使用原生的mathjax，又回到了之前的加载速度。 记一次智障操作自从建立整个博客以来，一个问题困扰了我好久，就是为啥我的博客生成的路径跟他们的都！不！一！样！这是我之前的文章路径： https://odinaris.github.io/undefined/06/28/hexo主题优化配置记录/ 于是我就陷入了深深的疑惑，在网上搜索也不得结果。到底为啥我的路径中有undefined啊！ 直到我在_config.yml中发现了这个： 1234url: http://odinaris.github.ioroot: /permalink: :yeard/:month/:day/:title/permalink_defaults: What the Fuck !? 我啥时候干的？一脸懵逼好嘛！ 删了那个该死的d之后，现在终于正常了： https://odinaris.github.io/2019/06/28/hexo主题优化配置记录/ 果然是瞎啊。。老年人玩什么博客。。```]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPEG隐写术之F5、-F5和nsF5]]></title>
    <url>%2F2019%2F06%2F27%2FJPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BF5%E3%80%81-F5%E5%92%8CnsF5%2F</url>
    <content type="text"><![CDATA[本文首先对JPEG隐写术中经典算法F5进行介绍，由于F5存在的缺陷，进而引出对改进算法-F5和nsF5的介绍，主要包括公式原理、源码分析等内容。 参考论文 Title Authors Statistically Undetectable JPEG Steganography: Dead Ends, Challenges, and Opportunities Fridrich, Jessica, Tomáš Pevný, and Jan Kodovský F5算法介绍F5算法包含两个重要的设计原则，嵌入的特点和矩阵编码。 嵌入特点F5算法的嵌入特点，是只会将DCT系数的绝对值减少1。 F5只嵌入到非零AC系数中。嵌入之后存在某非零系数变成0的情况，叫做收缩（shrinkage）现象。这种现象只会发生在原始系数值为正负1的系数身上。 因为解码器只从非零系数中读取秘密信息，如果修改成0之后，接收端无法确认当前读取的0是原始的零系数还是修改之后的零系数。因此嵌入之后如果生成新的0系数，可想而知，这个新的0系数所代表的秘密信息就无法提取出来。换句话说，其代表的特殊含义就泯然众人矣。 这时，需要跳过当前系数，重新将秘密数据嵌入到下个系数中。 矩阵编码矩阵编码可以使得在一个嵌入修改中嵌入更多的比特，从而增加嵌入效率。 下面举例说明矩阵编码的概念。 用$x$表示7个DCT系数的LSB（最低有效位），以列向量表示，即$x_{7\times1}$。 用m表示3比特秘密信息，也以列向量表示。 首先生成一个$3\times7$的二元矩阵$H$，其中每一列都是长度为3的非零向量： H= \left( \begin{matrix} 1 & 0 & 0 & 1 & 1 & 0 & 1\\ 0 & 1 & 0 & 1 & 0 & 1 & 1 \\ 0 & 0 & 1 & 0 & 1 & 1 & 1 \end{matrix} \right)嵌入时，首先检查$Hx=m$是否成立。如果等式成立，那么不需要进行任何嵌入修改就可以实现秘密信息嵌入（即$x=y$，$y$即stego矩阵中对应位置的系数的LSB列向量）。秘密信息m可以通过下式提取： m=Hy如果等式不成立，首先要找到$Hx$与$m$中不一致的列，比如第$j$列。然后通过改变$x$中第$j$个比特来嵌如秘密信息$m$。最终生成修改后的系数的LSB列向量，也就是$y$。 接收者可以通过使用相同的矩阵乘法来正确地从stego图像中提取出秘密信息: m=Hy因此，在这个例子中，通过矩阵编码，可以只造成平均1-1/2^3次修改就可以将3比特信息嵌入到7个DCT系数中。这里的1/2^3是因为当Hx=m时，不需要进行修改就可以嵌入数据，而等式成立的概率正好是1/8。 矩阵编码方法可以推广到更一般的形式： 通过造成至多1嵌入修改或者平均1-2^{-p}次修改，来将p比特数据嵌入到2^{p}-1个DCT系数中。 但事实上，F5的嵌入效率是达不到理想的嵌入效率的。这是因为 收缩现象的存在需要进行额外的嵌入修改。 收缩现象增加了嵌入操作对DCT系数直方图造成的影响。 收缩造成的负面效果可以通过几种方式消除，下面介绍的-F5和nsF5就是针对收缩现象而指定的解决方法。 -F5算法上文提到，F5的第一个设计原则，是将DCT系数的绝对值减1，这会导致收缩现象的产生。而-F5算法做的就是将减1改为加1，这样收缩现象就能避免，也就可以达到理想中的嵌入效率。 （-F5的缺点暂时不考虑） nsF5算法另一种解决方法是使用湿纸编码（Wet paper code）来减弱收缩造成的负面效果。 湿纸编码的思想是假设载体像一张湿了的纸一样，存在干点（dry point）和湿点（wet point）。湿点区域无法进行任何嵌入修改操作。 nsF5算法首先将置乱后的DCT系数进行分段之后，将零系数作为湿点，将非零系数作为干点进行湿纸编码。这样接收者只需要用共享的编码矩阵提取信息，而无需关心0的可能产生情况。]]></content>
      <categories>
        <category>Steganography</category>
      </categories>
      <tags>
        <tag>Steganography</tag>
        <tag>nsF5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPEG隐写术之J-UNIWARD]]></title>
    <url>%2F2019%2F06%2F26%2FJPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BJ-UNIWARD%2F</url>
    <content type="text"><![CDATA[本文对JPEG经典隐写术J-UNIWARD进行介绍，首先介绍方向滤波器组，然后解释失真函数的设计思想，最后介绍UNIWARD的加性近似过程。 参考论文 Title Authors Universal distortion function for steganography in an arbitrary domain Vojtˇech Holub, Jessica Fridrich and Tomáš Denemark Digital Image Steganography Using Universal Distortion Vojtˇech Holub and Jessica Fridrich 摘要近几年来，最成功的隐写术是在嵌入秘密数据的同时最小化一个适合定义的失真函数。而由于一些高效实用的编码存在（能够达到逼近率失真边界的嵌入效果），对于从事隐写术的科研工作者来说，本质上唯一剩下的任务就是设计失真函数。 这篇paper中提出了一种通用失真设计方案，UNIWARD（UNIversal WAvelet Relative Distortion，通用小波相对失真）。UNIWARD可以适用任何域，如空域（S-UNIWARD），JPEG域（J-UNIWARD）还有基于边信息的JPEG域（SI-UNIWARD）。 最近的隐写分析技术，如RM（Rich Model，富模型）可以通过使用局部多项式模型来很好地拟合clean edges上的改变，因而可以有效检测出clean edges上的改变。因此嵌入算法需要能够将数据嵌入在纹理或噪声区域，这些区域从任何方向上都不容易被建模，因此难以被检测。 UNIWARD的嵌入失真是载体图像的方向滤波器组分解中的系数的相对变化总和。这种方向性使得嵌入变化区域多集中在那些难以建模在多个方向的区域，如纹理和噪声区域，而避免了光滑区域或者clean edges被修改。 符号解释 Notation Expalanation \pmb{X} cover的量化后DCT系数矩阵 \pmb{Y} stego的量化后DCT系数矩阵 X_{ij} cover中第$i$行第$j$列的量化后DCT系数值 Y_{ij} stego中第$i$行第$j$列的量化后DCT系数值 n_1 行数 n_2 列数 方向滤波器组（Directional filter bank）方向滤波器组包括三个线性平移不变滤波器，他们的核用$\pmb{B}=\{\pmb{K}^{(1)},\pmb{K}^{(2)},\pmb{K}^{(3)}\}$表示。 这三个滤波器通过计算方向残差$\pmb{W}^{(k)}=\pmb{K}^{(k)}\star \pmb{X}$来分别从水平、垂直和对角线方向来评估给定图像$\pmb{X}$的光滑程度，其中$’\star’$表示镜像填充（mirror-padded）卷积操作使得方向残差$\pmb{W}^{(k)}$的尺寸与cover的量化后DCT系数矩阵尺寸一致，都是$n_1\times n_2$。镜像填充的作用是防止在边界处引入embedding artifacts。 滤波器组的选择是任意的，而在这里作者根据比对各种滤波器组之后，最终选择了从一维低通（和高通）小波分解滤波器来构建滤波器组的核： \pmb{K}^{1}=\pmb{h}\cdot\pmb{g}^T,\pmb{K}^{2}=\pmb{g}\cdot\pmb{h}^T,\pmb{K}^{3}=\pmb{g}\cdot\pmb{g}^T.这种情况下的滤波器分别对应于二维的LH，HL和HH小波方向高通滤波器，并且残差与$\pmb{X}$的第一级未抽取小波LH，HL和HH方向分解一致。滤波器只限于小波滤波器组，是因为小波表示是已知的能够为自然场景提供良好的去相关性（decorrelation）和能量紧凑化（energy compactification）。 失真函数（Distortion function）对于JPEG图像来说，计算cover和stego之间的失真，首先要将JPEG文件解压到空域，即此时的$\pmb{X}$和$\pmb{Y}$是对应的空域像素矩阵，而非DCT系数矩阵，失真可表示如下： \mathrm{D}(\pmb{X,Y})=\sum_{k=1}^3 \sum_{u,v} \frac{|W_{uv}^{k}(X)-W_{uv}^{k}(Y)|}{\epsilon+|W_{uv}^{k}(X)|}其中$\epsilon$是一个正数标量，用于避免分母为0。从上式看出，分母越大，最终失真也就越小。也就是在cover矩阵中，更大的小波系数发生修改造成更小的失真，而这一般是发生在纹理/噪声区域以及图像边缘部分。而另一方面，如果至少一个小的小波系数发生了较大改变，都会造成很大的失真。因此，在至少一个方向上，上式的设计不鼓励嵌入修改发生在内容相对平滑（平滑也更容易被建模）的区域。 UNIWARD的加性近似为什么要使用加性近似？在JPEG域中，当修改一个JPEG系数时，会同时影响一整个$8\times8$的像素块，因此有$23\times 23$大小的小波系数也会受到影响。因此当修改多个邻近的像素或者DCT系数时，造成的嵌入修改发生重叠，相互作用。因此失真$\mathrm{D}$是非加性的。 虽然存在一些使用非加性失真函数的嵌入方法，如Gibbs构造，但使用加性失真更容易进行嵌入。并且在UNIWARD中，相邻的嵌入修改造成的影响过于明显使得Gibbs构造的嵌入效果差强人意。UNIWARD不采用Gibbs构造的进一步解释可参考论文，这里不作过多赘述。 使用加性近似的显著优点是在全局设计上的便利性。因为嵌入过程可以直接通过使用隐写术中的一个标准工具 - STC码来实现。 如何定义加性近似？任何失真函数$\mathrm{D}(\pmb{X,Y})$都可以用来嵌入到加性近似中，通过使用D来计算修改每个像素值或DCT系数$X_{i,j}$的成本$\rho_{ij}$。 将$X_{i,j}$修改成$Y_{i,j}$并保持其他系数值不变的代价定义如下： \rho(\pmb{X},Y_{ij})=D(\pmb{X},\pmb{X}_{\sim ij}Y_{ij})其中$\pmb{X}_{\sim ij}Y_{ij}$是只有第$ij$个元素发生改变的$\pmb{X}$。当$\pmb{X}=\pmb{Y}$时，$\rho=0$。 用$D_A(\pmb{X,Y})$来表示加性近似： D_A(\pmb{X,Y} )=\sum_{i=1}^{n_1} \sum_{j=1}^{n_2} \rho_{ij} (\pmb{X}, Y_{ij} ) [X_{ij}\neq Y_{ij}]其中$[S]$用来表示艾弗森括号，当括号中的状态S为真时，等于1，否则为0。 由于失真函数$\mathrm{D}(\pmb{X,Y})$中的绝对值存在，表明 \rho_{ij}(\pmb{X},X_{ij}-1)=\rho_{ij}(\pmb{X},X_{ij}+1)这就使得UNIWARD可以使用三元嵌入操作，进一步提高嵌入效率。具体的嵌入算法构造可以使用STC码的三元多层版本。]]></content>
      <categories>
        <category>Steganography</category>
      </categories>
      <tags>
        <tag>Steganography</tag>
        <tag>J-UNIWARD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IEEEtran模板踩坑日志]]></title>
    <url>%2F2019%2F03%2F15%2FIEEEtran%E6%A8%A1%E6%9D%BF%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[最近有篇paper需要投稿到TCSVT，所以前几天下载了IEEEtran模板把之前的word版转换成latex版。因为编辑过程中遇到不少困难，故特地记录下来，方便自己以后查阅。 “section{}”中单词大小写问题在IEEEtran这个模板中，section{}部分中的内容默认全部格式化成大写，并且每个单词首字母字号更大一些，排查了一下，这个效果是与下面这段代码有关的，如果不想要大写，这段代码可以注释掉。 1\hyphenation&#123;op-tical net-works semi-conduc-tor&#125; 图例标注位置问题图例标注默认是左对齐的，我参考了TCSVT中的几篇文章，发现三篇文章对图例的样式设置都不一样 。一般来说当然是居中好看一些，由于不知道怎么直接修改位置，于是引用了”caption”包，可以设定图例的格式以及位置，比如可以设置成”Figure.”也可以设置成”Fig.”。但是发现修改之后表格的标注会自动修改。原本表格的caption内容是全部大写的，跟section{}中的内容一样，使用了caption包之后就会失去全部大写的效果。我目前放弃使用了caption包，等到下次编辑时看是否能找到好的解决方案。 花括号下多行公式左对齐解决办法12345678910\begin&#123;equation&#125;\nonumber\centering\left\&#123;\begin&#123;array&#125;&#123;lll&#125;N\leqslant N_u &amp; \\\sum_&#123;i=1&#125;^&#123;N&#125;p_i\leqslant N_n &amp; \\p_i=2^&#123;j&#125;-1,i\in 1,2,\cdots,N,j\in N^* &amp;\end&#123;array&#125;\right.\end&#123;equation&#125; 通栏公式(跨双栏)当论文中公式过长的时候，一栏很难展示的很好，也许可以通过\!调整位置或者通过\begin{small}来缩小公式字体，但过长的公式无论如何微调表现都不尽人意，这时候就需要利用通栏公式了。下图就是我想要得到的通栏公式的效果： 为此，查阅了不少博客，最终找到了一种有效的处理办法。附上博客地址： 跨双栏长公式的置顶/置底 12345678910111213\begin&#123;figure*&#125;\begin&#123;equation&#125; M_&#123;opt&#125;= \begin&#123;Bmatrix&#125; \begin&#123;aligned&#125; &amp; \left \&#123; HC_1\leftrightarrow \left \&#123; HC_2,\cdots ,HC_&#123;1+p_1^*&#125; \right \&#125; \right \&#125;,\\ &amp; \left \&#123; HC_&#123;2+p_1^*&#125;\leftrightarrow \left \&#123; HC_&#123;3+p_1^*&#125;,\cdots ,HC_&#123;p_1^*+p_2^*+2&#125; \right \&#125; \right \&#125;,\cdots,\\ &amp; \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N&#125;\leftrightarrow \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N+1&#125;,\cdots ,HC_&#123;\sum_&#123;i=1&#125;^&#123;N&#125;p_i^*+N&#125; \right \&#125; \right \&#125; \end&#123;aligned&#125; \end&#123;Bmatrix&#125; \label&#123;eq6&#125; \end&#123;equation&#125; \end&#123;figure*&#125; 上面这段代码就是图中双栏公式的实现代码，效果还算可以。 参考文献的引用还记得我第二篇paper在编辑参考文献bib文件的时候，一篇一篇地去Google scholar上查，然后一个属性一个属性的复试粘贴QAQ，想想都是泪，真的蠢。这次从Google scholar上发现可以直接点击BibTex就可以直接复制整段引用信息了，然后粘贴到bib文件里，效率比当时是快不少了。但是这样只能一篇一篇的复制，我不知道怎么批量导入，这个还需要查查资料才行。 表格内文字自动换行问题在写算法步骤时，很多时候是采用表格形式展示的，这时候就要使得文字过长的一行可以自动换行了，查询资料之后，找到一种办法效果挺好，就是限定每列固定长度： 123456789101112131415\begin&#123;table&#125;[!ht]\renewcommand\arraystretch&#123;1.3&#125;\caption&#123;Embedding steps of the proposed scheme.&#125;\label&#123;tab2&#125;\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125;\toprule\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Input:&#125; Original JPEG bitstream $J$ and secret data.&#125; \\\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Output:&#125; Marked JPEG bitstream $J_M$. &#125; \\ \midrule\textbf&#123;Step 1.&#125; &amp; Parse the entropy coded data and the DHT segment from $J$. \\\textbf&#123;Step 2.&#125; &amp; Count the frequency of RSVs according to the corresponding Huffman codes and sort the RSVs in descending order. \\\textbf&#123;Step 3.&#125; &amp; Construct the optimal mapping relationship $M_&#123;opt&#125;$ according to the given payload. \\\textbf&#123;Step 4.&#125; &amp; Replace the original Huffman codes in $J$ with the Huffman codes in the mapping set to embed data. \\\textbf&#123;Step 5.&#125; &amp; Modify the RSVs in the DHT segment according to $M_&#123;opt&#125;$, then $J_M$ is generated. \\ \bottomrule\end&#123;tabular&#125;\end&#123;table&#125; 得到的效果图如下： 我觉得效果还是不错的，这段代码核心就是 1\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125; 通过指定每列固定长度来使得超过长度文字能够自动换行。 表格行间距设置问题就一行代码，比较简单，在\begin{table}下加上 1\renewcommand\arraystretch&#123;1.5&#125; 即可，很实用。]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
</search>
