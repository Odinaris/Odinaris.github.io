<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>About My Time.</title>
  
  <subtitle>我欲因之梦吴越，一夜飞度镜湖月。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://odinaris.github.io/"/>
  <updated>2020-05-23T07:00:52.099Z</updated>
  <id>http://odinaris.github.io/</id>
  
  <author>
    <name>YangDu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知易行难</title>
    <link href="http://odinaris.github.io/2020/05/22/%E7%9F%A5%E6%98%93%E8%A1%8C%E9%9A%BE/"/>
    <id>http://odinaris.github.io/2020/05/22/知易行难/</id>
    <published>2020-05-22T04:02:30.000Z</published>
    <updated>2020-05-23T07:00:52.099Z</updated>
    
    <content type="html"><![CDATA[<p>自己没有的永远是最好的，这真的是经得起考验的真理。</p><a id="more"></a><p>恋爱时觉得单身就好了，能省下钱来买自己想买的东西，可以自由支配自己的时间。</p><p>单身时觉得恋爱最好，什么事情都可以跟另一半倾诉，两个人互相扶持，有笑有泪。</p><p>为什么人很难能够在当下的时候感受到当下的美好呢？</p><p>就像树欲静而风不止，子欲养而亲不待。</p><p>人不是在失去后才知道拥有的可贵，人是在未拥有时觉得拥有可贵，拥有了反而觉得累赘。如此反复。</p><p>这么看来人似乎是不长记性地生活着。</p><p>人对是否拥有总是感受于当下，总是不满于当下的状况。</p><p>接着就会演化为失去，离别。</p><p>所谓分久必合，合久必分，又如昨天看到知乎的一篇文章。愚钝到聪明到通透，再到又一轮的愚钝。</p><p>这一轮轮的循环，是否说明没有必要去争取，去演化？</p><p>不是的，这种循环，并不是没有发展的。可以是螺旋上升，也可以是螺旋下降。即好的愈好，坏的愈坏。</p><p>文字写得很乱，主要是由这几天所闻所感汇集成的想法。不成体系，观者见谅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己没有的永远是最好的，这真的是经得起考验的真理。&lt;/p&gt;
    
    </summary>
    
      <category term="人生啊" scheme="http://odinaris.github.io/categories/%E4%BA%BA%E7%94%9F%E5%95%8A/"/>
    
    
      <category term="2020" scheme="http://odinaris.github.io/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2019，繁华散尽</title>
    <link href="http://odinaris.github.io/2019/12/31/2019-%E7%B9%81%E5%8D%8E%E6%95%A3%E5%B0%BD/"/>
    <id>http://odinaris.github.io/2019/12/31/2019-繁华散尽/</id>
    <published>2019-12-31T11:02:30.000Z</published>
    <updated>2019-12-31T13:01:47.592Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，杜洋，好久不见。距离上一次博客有四个多月了呢。</p><p>正值年末，让我来回顾下这漫长而短暂的一年罢。日后回看，也必是甘之如饴的静好岁月。</p><a id="more"></a><h3 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h3><p>今年二战，成功上岸。虽然没有拿到奖学金，但总归是没有再度让父母失望。</p><p>关于考研，难忘我的父母，对我的包容，对我的相信，和我对他们的歉疚，对自己的失望。</p><p>我不知道你们在外人面前说起我的考研成绩时，是什么样的心情，也不知道得知我没有考上时是什么样的心情。</p><p>可能在你们心里，考不上研没有什么大不了，毕竟整个家族就没几个研究生；可是你们又对曾经成绩优异的我如此放心，根本没有料到我会考试失利吧。</p><p>在我看来，外人询问我成绩时，是你们庇护了失意的我，让我不至于难堪，不至于尴尬。</p><p>今年初试成绩出来之后，我爸确定分数之后还问我是不是能确保考上。我知道，过去的一年，他一点也不好受，每次别人问起，他都要想办法搪塞过去。</p><p>这次，他终于能够拍着胸脯向别人宣布我真的是一名研究生了。</p><p>我感激他们对我的相信，对我的支持，对我的爱护，爸，妈，我骨子里是一个极度自私的人，但，我真的很感谢你们。</p><h3 id="恋止"><a href="#恋止" class="headerlink" title="恋止"></a>恋止</h3><p>二月底的时候，我跟她的感情走到了终结。是我先提的分手。</p><p>往后的日日夜夜，数不清多少次后悔分手，这样就可以不用看到别人成双成对，自己形单影只。</p><p>之后也尝试复合，但我已伤她太深，换做是我，也不会同意。何况我也没有表现出我的诚意。</p><p>虽然挽回不了，但我仍感谢你四年的陪伴，照亮了我灰暗的大学生活，让我第一次有想要为某个人奋斗的意愿。这段感情，这段回忆，现在回想也依旧美好。</p><p>从大一下，到大五上。</p><p>从15年春，到19年春。</p><p>从一个人，到一个人。</p><p>谢谢你，岑岑。</p><h3 id="学车（“赋闲”）"><a href="#学车（“赋闲”）" class="headerlink" title="学车（“赋闲”）"></a>学车（“赋闲”）</h3><p>四月初的时候，回家学了三个月的车。驾照顺利get，虽然对我没什么用，但也算了却一桩琐事。</p><p>结识了同期学车的一些人，小胖，王玥，李毅…</p><p>小胖陪我最多，他很胖，但人很好，虽然有时傻傻的，但是学车很快。</p><p>王玥很漂亮，当时还对她有意思。她的家庭经历让我唏嘘，愿她现在安好吧。</p><p>李毅打游戏很厉害，还拿过名次。</p><p>他们都才18，9岁，相较之下，我好像并没有比他们成熟多少。虽然我已23。</p><hr><p>在家这几个月，学会了不少炒菜，甚至土豆牛肉都能做得有模有样。</p><p>做菜的状态也经历了兴奋到平淡下来的过程。</p><p>感受就是，还是身边有人能愿意点评你的菜才有继续做下去的动力啊。</p><p>我妈总是中午不在家，所以中午就没心思做饭，只有到晚上，才想要做几个菜，然后问我妈做的怎么样。据她说说，我做的菜还挺好吃的，哈哈~</p><hr><p>这期间，发生一件很伤我妈心的事。有一次我妈问我科目三的事情，跟她顶了句嘴，话说的很重。我本意也不是那样，可是祸从口出，终究是让她很痛心。想想现在，她似乎像没发生过那件事一样对我好，但我知道，她不是健忘的人。只不过伤她心的人是她儿子罢了。</p><p>对不起，妈。</p><hr><p>因为在家学车，也没有赶上濮阳他们毕业聚餐和合照。现在想想，很是遗憾。</p><p>当时还在感慨，自己总是错过毕业的事。大学毕业时候的班级合照没有我，濮阳毕业合照也没有我。当时毕业时，岑岑给我拍了很多张我的学士服照片，可是分手前也没有问她要，所以现在我基本上没有毕业时候的照片了。果然分手什么的，最坏不过了。</p><h3 id="归校（暑假）"><a href="#归校（暑假）" class="headerlink" title="归校（暑假）"></a>归校（暑假）</h3><p>驾照拿到以后，就回到了心心念念的学校。当时刚刚分手没多久，一个人在家待了几个月，整个人都要自闭了。</p><p>现在想想暑假还是发生了不少事的。</p><p>分宿舍的时候因为不是应届本校生，还不能一起分宿舍，导致在行知楼自己住了半个月。洗澡洗衣服全都要跑到楼上卫生间，我到现在，还记得，卫生间门口的蟑螂！心有余悸哈哈。然后就是那瓶万能的洗发露，不仅可以洗头，还能当沐浴露，洗衣液！当时只能等到晚上十二点再去楼上，担心去的早有人没走。结果怕黑就用手机放郭德纲的相声哈哈，现在想想当时那段日子，真的挺有意思的~</p><p>这段期间，之前投稿的CSVT论文主编发邮件说被拒了。当时七点多，我在吃早饭的路上，看到消息真的难受呀。关键是审稿意见说的我还反驳不了什么，因为说的确实很有道理。所以虽然不开心，但也只好接受了~</p><h3 id="开学"><a href="#开学" class="headerlink" title="开学"></a>开学</h3><p>自从九月开学以来，状态由踌躇满志到怀疑人生到颓废不堪到接受现实，每一步都历历在目。</p><p>这学期以来，我开始管理组费。九月份的时候，组织了一次团建活动（轰趴），带大家去别墅玩了一天。当时的感觉挺好的。但我本身不太习惯跟多人共处，并且组里的女生一直在厨房做饭，一直忙到下午三四点才吃上，吃完也没玩多久就要做晚饭。当时感觉挺对不起他们，是自己做事考虑不周了。不过这次活动，大家应该玩的还是挺开心的。</p><p>这学期，我能感受到自己的改变，但也有始终学不会的事情。</p><p>学会了骑车，感受到了骑车的快感；</p><p>办了健身卡，感受到了挥汗如雨，大口喘气的疲惫而拼搏的畅快；</p><p>但是人际交往依旧不知道怎样自己踏出第一步；</p><p>仍然做事不够专注。</p><p>去了厦门，感受了国内学术会议的氛围，以及厦门海鲜的难吃~</p><h3 id="2020，俺来咯"><a href="#2020，俺来咯" class="headerlink" title="2020，俺来咯~"></a>2020，俺来咯~</h3><p>这一年发生了太多太多，本来心血来潮想要好好总结一番，结果发现怎么写都没法写完自己想要写的事情。</p><p>那就写到哪算哪吧~</p><p>今年是2019年最后一天，实验室大部分人都出去跨年了。单身就这点不好，但是晚上去食堂吃饭的路上，想想，也没什么大不了的，一个人也挺好的。</p><p>明天就是新的一年啦，小杜洋，来年你想做啥嘞？想成为什么样的人嘞？想发几篇paper嘞？想遇见什么的人嘞？</p><p>哈哈哈，正因为一切都是未知，才有了坚持下去的动力吧。</p><p>不坚持到2020年最后一刻，你咋知道2020是什么样的嘞~</p><p>2019年，我过得很好，虽然失去了一些人一些物，但也得到了一些人，一些物。</p><p>繁华散尽，更有新的美好等我。</p><p>2020，我的本命年，我来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hi，杜洋，好久不见。距离上一次博客有四个多月了呢。&lt;/p&gt;
&lt;p&gt;正值年末，让我来回顾下这漫长而短暂的一年罢。日后回看，也必是甘之如饴的静好岁月。&lt;/p&gt;
    
    </summary>
    
      <category term="人生啊" scheme="http://odinaris.github.io/categories/%E4%BA%BA%E7%94%9F%E5%95%8A/"/>
    
    
      <category term="2019" scheme="http://odinaris.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>关于数字图像中的冗余</title>
    <link href="http://odinaris.github.io/2019/07/13/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E5%86%97%E4%BD%99/"/>
    <id>http://odinaris.github.io/2019/07/13/关于数字图像中的冗余/</id>
    <published>2019-07-13T02:19:09.000Z</published>
    <updated>2019-11-19T02:16:26.206Z</updated>
    
    <content type="html"><![CDATA[<p>因为信息隐藏的实现依赖于图像自身存在的冗余，此文首先分析了信息隐藏与图像冗余之间的关系，然后介绍了关于数字图像中存在的几种冗余。</p><a id="more"></a><h1 id="信息隐藏与图像冗余"><a href="#信息隐藏与图像冗余" class="headerlink" title="信息隐藏与图像冗余"></a>信息隐藏与图像冗余</h1><p>对于我个人来说，更喜欢从信息论，图像压缩的角度来更深刻地理解信息隐藏的意义。</p><p>一些从事信息隐藏的人认为图像中存在的冗余是能够实现信息隐藏这一技术的重要条件，比如黄方军教授在《Reversible Data Hiding in JPEG Images》中提到的一样。</p><p>最近写的几篇关于JPEG信息隐藏的论文，都难免避不过对冗余的解释。</p><p>因为在谈及为什么JPEG可逆信息隐藏的工作目前这么少时，总会用设计JPEG中RDH比空域RDH更困难来解释。</p><p>那么为什么JPEG中的RDH设计更困难呢？</p><p>很多人都对此作了分析，我们导师，黄方军教授等等，主要分为三点：</p><ul><li>JPEG冗余度比空域图像低</li><li>对JPEG图像的轻微修改引起的失真明显</li><li>空域图像中的率失真性能指标不适用于JPEG图像</li></ul><p>现主要对第一点作介绍，其他与冗余关联不大，不在本文介绍。</p><p>首先，图像文件与图像本身是有区别的，这点应该不难理解。</p><p>从我个人对空域RDH这几年耳濡目染得到的经验来看，空域RDH只讨论如何修改图像本身的像素矩阵。这些512*512的数据的矩阵就是他们的用武之地。</p><p>可以说，他们研究的是图像而不是图像文件。虽然我依稀记得，有些论文是利用到了Bitmap图像的调色板属性，但这方面毕竟太少。</p><p>但是对于其他载体，比如PNG, JPEG, GIF等等，无一不须考虑到其特定的文件编码格式。</p><p>这就有点意思了，研究的作用域都不太一样，为什么空域就不需要考虑文件编码格式呢？</p><p>这就回到冗余的角度了。因为像素间冗余是冗余的一种，而空域图像中这些冗余没有被压缩，所以这些冗余被各种腾转挪移来设计RDH方案。而对于压缩的图像，就不得不从其他角度来考虑RDH的设计。</p><p>对于压缩图像来说，天无绝人之路，因为冗余并非这一种，接下来，我就根据查阅的资料对冗余的分类及具体解释作个介绍。</p><h1 id="图像冗余介绍"><a href="#图像冗余介绍" class="headerlink" title="图像冗余介绍"></a>图像冗余介绍</h1><p>冗余可以被分成<strong>统计冗余</strong>和<strong>心理视觉冗余</strong>两种。</p><p>首先可以对冗余进行如下分类：</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/%E5%9B%BE%E5%83%8F%E5%86%97%E4%BD%99%E4%BB%8B%E7%BB%8D/%E5%9B%BE%E5%83%8F%E5%86%97%E4%BD%99%E4%BB%8B%E7%BB%8D.png" alt></p><ul><li>相邻像素值之间存在空间冗余或相关性。</li><li>不同颜色平面或光谱带之间存在光谱冗余或相关性。</li><li>视频应用中图像序列中相邻帧之间存在时间冗余或相关性。</li></ul><p>图像压缩研究旨在通过尽可能地去除空间和光谱冗余来减少表示图像所需的比特数。</p><p>在数字图像压缩中，<strong>编码冗余</strong>、<strong>像素间冗余</strong>和<strong>心理视觉冗余</strong>是可确定被用于压缩的。</p><ul><li><strong>编码冗余</strong><br>编码冗余与信息表示有关。而信息以编码的形式表示。<br>如果以使用比表示每个灰度级必要的更多代码符号的方式对图像的灰度级进行编码，则所得到的图像可以说是包含了编码冗余。<br>这个可以解释说，每种灰度级的编码长度并不应该是相等的，也就是哈夫曼码所解决的问题。通过每种灰度级的权重来分配不等长的编码，从而减少编码冗余。</li><li><strong>像素间空间冗余</strong><br>像素间冗余是由于图像中相邻像素之间存在相关性。也就是说相邻的像素在统计上是不独立的，任何给定的像素值都可以根据它相邻的的像素值来预测到，这叫做高相关性。<br>独立的像素所携带的信息相对很小，为了减少像素间冗余，相邻像素间的差值可以被用来表示一张图像。</li><li><strong>像素间时间冗余</strong><br>像素间时间冗余是指在视频序列中连续帧中的像素间的相关性。<br>时间冗余也被称作帧间冗余。可以使用运动补偿预测编码来利用时间冗余。</li><li><strong>心理视觉冗余</strong><br>存在心理视觉冗余是因为人类感知不涉及图像中每个像素或亮度值的定量分析。也就是说，人类对像素值的微小改动是不敏感的，因为人眼不能对像素值进行定量分析。<br>因此消除一些真实的视觉信息是可能的，但这仅仅适合这个信息本身对于正常的视觉处理是不必要的情况下。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.ques10.com/p/7293/what-are-different-types-of-redundancies-in-digi-1/" target="_blank" rel="noopener">Question: What are different types of redundancies in digital image? Explain in detail.</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为信息隐藏的实现依赖于图像自身存在的冗余，此文首先分析了信息隐藏与图像冗余之间的关系，然后介绍了关于数字图像中存在的几种冗余。&lt;/p&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://odinaris.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="图像处理" scheme="http://odinaris.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像压缩" scheme="http://odinaris.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之UERD</title>
    <link href="http://odinaris.github.io/2019/07/02/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BUERD/"/>
    <id>http://odinaris.github.io/2019/07/02/JPEG隐写术之UERD/</id>
    <published>2019-07-02T08:29:09.000Z</published>
    <updated>2019-11-19T02:16:12.286Z</updated>
    
    <content type="html"><![CDATA[<p>本文对JPEG隐写术中的UERD算法进行相关介绍。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Using Statistical Image Model for JPEG Steganography: Uniform Embedding Revisited</td><td>Linjie Guo, Jiangqun Ni, Wenkang Su, Chengpei Tang, and Yun Qing Shi</td></tr></tbody></table></div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>UERD这篇论文主要工作可以概况为以下三点：</p><ul><li>使用了所有的DCT系数（包括DC和零AC系数在内）作为载体元素</li><li>基于DCT块和每个DCT系数的模式来构造失真函数</li><li>计算复杂度可忽略不计，更实用</li></ul><h1 id="对UED的攻讦"><a href="#对UED的攻讦" class="headerlink" title="对UED的攻讦"></a>对UED的攻讦</h1><p>UED存在的问题主要有两点：</p><p>一、对原始的均匀嵌入（UE）策略可以从信息论的视角来理解，即<strong>离散源的最大熵原理</strong>。但是对于自然图像来说，<strong>不同大小的DCT系数可容忍的相对变化是不同的</strong>。就是说，对两种值不同的系数进行相同的修改，造成的影响是不同的。</p><p>二、对修改的“均匀扩展”是否真的能够得到最佳的安全性？</p><h1 id="广义均匀嵌入策略（Generalized-Uniform-Embedding）"><a href="#广义均匀嵌入策略（Generalized-Uniform-Embedding）" class="headerlink" title="广义均匀嵌入策略（Generalized Uniform Embedding）"></a>广义均匀嵌入策略（Generalized Uniform Embedding）</h1><blockquote><p><strong>UED的核心思想是将嵌入造成的修改均匀扩散到全体DCT系数中，而UERD的核心思想是将“检测能力”均匀扩散到全体系数。</strong></p></blockquote><p>上一篇文章介绍UED时提到了变异系数这个概念。变异系数Cv在一阶二阶统计上都表现出了随系数增大而增大的特性，换句话说，就是对系数的<strong>检测能力随着系数增大会下降</strong>。</p><p>UE中采用的是$1/|x|$这种衡量失真的形式，目的在于使得每种系数被选择到用来修改的<strong>“概率”</strong>一样，以达到均匀嵌入的目的。但实际上，这只是不同大小的系数被选择嵌入的概率是均匀的，而非真正意义上的均匀嵌入。因为不同大小的系数进行同样的修改，检测到的影响是不同的。越大的系数进行修改造成的影响越小。</p><p>因此，更合理的选择策略实要将这种“检测能力”均匀扩散到整个系数空间中。为此，需要控制每种系数的相对变化与变异系数$Cv$成比例就可。这种思想叫做广义均匀嵌入策略（Generalized Uniform Embedding）。</p><h1 id="UERD（Uniform-Embedding-Revisted-Distortion）设计"><a href="#UERD（Uniform-Embedding-Revisted-Distortion）设计" class="headerlink" title="UERD（Uniform Embedding Revisted Distortion）设计"></a>UERD（Uniform Embedding Revisted Distortion）设计</h1><p>实现广义均匀嵌入的一般做法是增加具有更大的CV的系数的嵌入几率。</p><p>因为单单比较系数并不能表示任何统计特性，因此作者研究了系数的位置对于CV的影响。而位置的影响主要包括的是AC模式和DCT块来表示。</p><p><strong>注</strong>：这里对AC模式没有进行解释，从上下文内容来看，我猜测是说AC系数在块中的位置，因为文中提到说模式00指的是DC模式，而DC的位置就是左上角也就是位于(0,0)处。下文中所有提到的AC模式，都默认按照AC系数在DCT块中的位置来理解，如AC模式10就是指位于(1,0)位置上的AC系数值得统计直方图。</p><p>首先，作者探究了不同AC模式的统计特性，统计结果表明，<strong>AC模式所处频率越高（右下角），对应的AC系数中拥有的零系数越多，对应的CV值也越低</strong>。说明这些系数被选择修改的概率越低。</p><p>然后，作者探究了具有不同纹理复杂度的块的统计特性。这里衡量纹理复杂度的方式是根据块中非零系数的个数来评判。非零系数越少，复杂度越低。文中将复杂度分级为如下四类：</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562079670314.png" alt="图1. DCT块纹理复杂度分级情况"></p><p>拿第一类来说明，块中非零AC系数个数在0-8之间时，就被分类为最低的纹理复杂度水平。</p><p>统计结果表明，<strong>DCT块中零AC系数个数越多，也就是纹理复杂度越低，对应的CV值就越低</strong>，这些块被选择来修改的概率越低。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562080724299.png" alt="图2. AC模式10下的DCT系数的CV值分布情况"></p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562081309344.png" alt="图3. AC模式33下的DCT系数的CV值分布情况"></p><p>从图2可以看出，零AC系数的CV值在相同模式下也存在比其他非零AC系数值高的情况。而用图2和图3对比可以看出，低频AC模式下的零系数CV值是高于高频AC模式下的零系数CV值的。</p><p>结合这两种实验数据可以看出，<strong>低频AC模式下的零系数CV值高于高频AC模式下的零系数CV值，甚至高于相同模式下的非零系数CV值</strong>。而高纹理复杂度下得零系数CV值比低纹理复杂度下的要高很多，甚至比低纹理复杂度下的其他非零系数CV值都要高。</p><p>这两种情况都证明了<strong>确实存在有比一些非零AC系数更适合嵌入的零AC系数</strong>。</p><p>基于以上发现，作者定义了均匀嵌入重访失真（Uniform Embedding Revisted Distortion）函数$\rho_{ij}$。</p><p>用$x_{ij}$表示在$(i,j)$位置上的DCT系数，$\rho_{ij}$定义如下：</p><script type="math/tex; mode=display">\rho_{ij}=\rho_{ij,mode}\cdot \rho_{ij,block}</script><p>其中$\rho_{ij,mode}$和$\rho_{ij,block}$分别对应于AC模式和DCT块的失真度量。这两个度量的选择有很多种。作者在论文里将AC模式的失真度量定义为对应位置上的量化步长。而DCT块的失真度量定义为$x_{ij}$所属块以及相邻块的能量函数。 假设$x_{ij}$处在第$mn$块中，那么它的块能量$D_{mn}$定义如下：</p><script type="math/tex; mode=display">D_{mn}=\sum^7_{k=0}\sum^7_{l=0}|x_{kl}|\cdot q_{kl}</script><p>其中$x_{kl}$表示的是块中对应位置上的系数值，并且设$x_{00}=0$来避免DC系数造成的影响，$q_{kl}$就是对应位置上的量化步长。</p><p>最终$\rho_{ij}$就可以表示如下:</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562084453236.png" alt="UERD失真计算公式"></p><p>（公式有点复杂，不想写latex公式了，偷个懒，哈哈）</p><p>其中$\hat{D}=\{D_{(m-1)(n-1)},D_{(m-1)n},D_{(m-1)(n+1)},D_{m(n-1)},D_{m(n+1)},D_{(m+1)(n-1)},D_{(m+1)n},D_{(m+1)(n+1)}\}$</p><p>是第$mn$个块的相邻八个块的块能量。</p><p>考虑到DC系数的统计特性与AC系数有很大不同，这里作者启发式地将DC系数的失真定义为相邻的AC系数的均值。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>UERD的介绍到此为止，最近调研文献时又发现了一篇18年的TCSVT，文章是对UERD进行的进一步改进，还是他们课题组的。具体没有细看，等有机会阅读完之后再决定是否介绍那一篇吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对JPEG隐写术中的UERD算法进行相关介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="UERD" scheme="http://odinaris.github.io/tags/UERD/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之UED</title>
    <link href="http://odinaris.github.io/2019/07/01/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BUED/"/>
    <id>http://odinaris.github.io/2019/07/01/JPEG隐写术之UED/</id>
    <published>2019-07-01T13:55:36.000Z</published>
    <updated>2019-11-19T02:13:18.786Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了JPEG隐写术中的UED算法。首先介绍了JPEG的统计特性与隐写分析之间的关系，然后介绍了nsF5算法的修改策略，从而引出均匀嵌入（Uniform Embedding）策略的思想并给出了均匀嵌入失真（Uniform Embedding Distortion）函数的公式。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Uniform Embedding for Efficient JPEG Steganography</td><td>Linjie Guo, Jiangqun Ni, and Yun Qing Shi</td></tr></tbody></table></div><h1 id="JPEG统计特征"><a href="#JPEG统计特征" class="headerlink" title="JPEG统计特征"></a>JPEG统计特征</h1><p>隐写分析中通常使用量化后的DCT系数来构建特征集合，用以检测JPEG隐写术。实际上，块DCT系数中的直方图和共生矩阵被广泛使用在隐写分析中。直方图对应的是一阶统计，共生矩阵对应的是二阶统计（可以捕获DCT系数之间的相关性）。</p><p>一旦有秘密信息被嵌入到JPEG图像中，DCT系数的统计就会有一定程度的修改，这就给隐写分析留下了踪迹。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562030760847.png" alt="图1. DCT系数的直方图和共生矩阵"></p><p>图1是JPEG原始DCT系数的直方图和共生矩阵。其中共生矩阵中的X2是X1的相邻系数，移动步长为1。可以看出，绝大部分系数都集中在0以及0附近。</p><p>可以认为DCT系数的一阶统计特征是<strong>类拉普拉斯分布</strong>的，这个事实需要注意。</p><h1 id="nsF5的嵌入变化"><a href="#nsF5的嵌入变化" class="headerlink" title="nsF5的嵌入变化"></a>nsF5的嵌入变化</h1><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562031911495.png" alt="图2. 使用nsF5得到的被修改的DCT系数分布直方图"></p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562032063409.png" alt="图3. nsF5相对于原始直方图的修改统计"></p><p>图2是DCT系数使用nsF5算法进行嵌入之后得到的修改后的直方图，可以看到基本上0系数已经移动到左右两边了。图3是对这些修改的统计，可以看出在0系数以及附近的修改所占比重明显。空间有限，这里就不展示共生矩阵的嵌入变化了，但基本上是与一阶统计特性相似的。</p><h1 id="nsF5是如何修改的？"><a href="#nsF5是如何修改的？" class="headerlink" title="nsF5是如何修改的？"></a>nsF5是如何修改的？</h1><p>想要理解为什么nsF5嵌入修改之后会造成上文所述的变化，就要先了解nsF5的工作流程。</p><p>对于给定载荷<script type="math/tex">\alpha</script>，nsF5的具体工作流程如下：</p><ol><li>根据<script type="math/tex">\alpha</script>计算嵌入效率的理论界限;</li><li>计算需要被修改的系数个数<script type="math/tex">n</script>；</li><li>随机选择<script type="math/tex">n</script>个非零AC系数并将他们的绝对值减1.</li></ol><p>上文提到，DCT系数的分布是类拉普拉斯分布的，而nsF5所采用的随机选择策略，会导致大部分被修改的系数都是绝对值小的系数。也就是图中所展示的，大部分修改后的系数集中在绝对值2以内。</p><h1 id="何为均匀嵌入（Uniform-Embedding）？"><a href="#何为均匀嵌入（Uniform-Embedding）？" class="headerlink" title="何为均匀嵌入（Uniform Embedding）？"></a>何为均匀嵌入（Uniform Embedding）？</h1><p>通过利用DCT系数的统计分布特征（类拉普拉斯分布），大部分隐写分析检测JPEG隐写术都可以获得高准确率。对于JPEG隐写术来说，即使采用一种更为有效的编码策略来使得总的系数修改数降低，嵌入后的修改系数分布特征还是相似的。这样还是会很容易被隐写分析者检测出来。</p><p>这时，均匀嵌入策略就异军突起，走向历史舞台了。</p><p>UE策略试图将对系数的嵌入修改扩展到所有存在的系数中去来最小化每个bin（直方图中，列可以叫做bin）的统计变化。这类似于扩频通信（spread specturm）的思想，关于扩频通信，我学通信的朋友生动地给我手绘了一张图来说明：</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562035927784.png" alt="来自某吊打985的top211的胡傲天的亲笔手绘扩频通信原理"></p><p>这是意识流的解释，懂的自然懂（滑稽）。</p><h1 id="均匀嵌入失真函数（UED）的设计思想"><a href="#均匀嵌入失真函数（UED）的设计思想" class="headerlink" title="均匀嵌入失真函数（UED）的设计思想"></a>均匀嵌入失真函数（UED）的设计思想</h1><p>为了能够完成均匀嵌入，使用到的失真函数必须设计成不同大小的系数都能够以相同的优先级被选择到。这个失真函数就称作是均匀嵌入失真函数（Uniform Embedding Distortion）。</p><p>用x表示具有类拉普拉斯分布特征的DCT系数，那么UED使用到的失真函数应该具有下面这种形式：</p><script type="math/tex; mode=display">\rho(x)=1/|x|</script><p>系数值越大，失真判定越小，被选择用于嵌入修改的概率也就越大。即，系数x被选择的概率随着x的绝对值增大而减小，成反比。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562036863430.png" alt="图4. UED的分布曲线"></p><p>图4绘制了上述介绍的分布的大致曲线，a是DCT系数的分布，b就是UED每个系数被选择的概率分布，c就是被选择的系数分布的大致曲线。</p><h1 id="对自然图像模型的参考"><a href="#对自然图像模型的参考" class="headerlink" title="对自然图像模型的参考"></a>对自然图像模型的参考</h1><p>很明显看出，使用UED来设计失真时，对绝对值大的DCT系数的修改数量是高于之前提出的方法的。</p><p>现有的JPEG隐写分析方法一般会利用自然图像模型的优势，即根据量化后DCT系数的一阶和二阶统计特性来进行隐写分析。</p><p>如果某种图像模型可以准确的表示DCT系数的分布状况（我的理解是能够对分布情况提出合理的量化表述），那么对载体进行任何轻微的修改都会被检测出来。</p><p>幸运的是，对于自然图像来说，DCT系数的分布严重依赖图像内容，每种内容不同的图像的分布特征都有明显差别。也就是说自然图像的统计特征没有任何一种图像模型可以准确估计出来。这对于隐写术来说，无疑是件好事。</p><p>为了证明自然图像在一阶和二阶统计上的偏差，作者首先计算直方图$p(x)$的均值$\mu(x)$和标准差$\sigma(x)$。然后用归一化变异系数（coefficient of variation）来定义标准差和均值的比：</p><script type="math/tex; mode=display">Cv(x)=\frac {\sigma(x)} {\mu(x)}</script><p>这里就体现了用相对变化来衡量失真的作用，因为<strong>无论用均值和标准差来独自证明检测能力随系数值的变化，都是不合理的</strong>。</p><p>篇幅限制，这些量随系数绝对值增大的变化这里不作展示，只陈述结果。</p><p>作者发现，$Cv(x)$随着$x$的绝对值增加而增加，这说明随着$x$的绝对值增加，DCT系数直方图偏差严重 ，这句十分不理解，但结合论文中对二阶统计的介绍，是说随着系数增大，更难以去建模统计特征，也就是抗隐写分析的能力更好吧（存疑）。</p><p>根据这个结论，如果使每个$x$的相对修改率与它自身的$Cv$值成比例的话，就可以使得对所有x做出均匀的修改，并且一阶统计特性的统计影响也能最小化。在二阶统计上也观察到了相似的效果。因此，修改一个DCT系数，在统计上的影响依赖于系数本身大小以及和它相邻的系数大小。</p><h1 id="均匀嵌入失真函数的设计"><a href="#均匀嵌入失真函数的设计" class="headerlink" title="均匀嵌入失真函数的设计"></a>均匀嵌入失真函数的设计</h1><ul><li>基于单系数的均匀嵌入失真（SC-UED）</li></ul><p>用$c_{ij}$表示在$(i,j)$位置上的DCT系数，SC-UED可以设计如下：</p><script type="math/tex; mode=display">\rho_{ij}^{SC}=|c_{ij}|^{-1}.</script><p>没错，就是上面提到的失真函数设计思想中的一般形式。 </p><ul><li>基于联合系数的均匀嵌入失真（JC-UED）</li></ul><p>设计更加实用的UED，不知需要考虑到DCT系数自身大小，它的块间和块内相邻的系数都需要被考虑在内。作者认为块内和块间相邻系数有着最强的数值相关性。将多个系数同时考虑在内的失真函数就是基于联合系数的均匀嵌入失真（JC-UED）：</p><script type="math/tex; mode=display">\rho_{ij}^{JC}=\sum_{d_{ia} \in N_{ia}}(|c_{ij}|+|d_{ia}|+a_{ia})^{-1}+\sum_{d_{ir} \in N_{ir}}(|c_{ij}|+|d_{ir}|+a_{ir})^{-1}.</script><p>其中$N_{ia}=\{c_{i+1,j},c_{i-1,j},c_{i,j+1},c_{i,j-1}\}$和$N_{ir}=\{c_{i+8j},c_{i-8,j},c_{i,j+8},c_{i,j-8}\}$分别表示块内相邻系数和块间相邻系数。$a_{ia}$和$a_{ir}$是调节参数，具体值可根据实验确定。</p><h1 id="对UED的总结"><a href="#对UED的总结" class="headerlink" title="对UED的总结"></a>对UED的总结</h1><p>因为以往的JPEG隐写术，如nsF5算法对于DCT系数的修改大都集中在零AC系数附近，这是由DCT系数的类拉普拉斯分布及随机选择策略决定的。为了减少这种明显的隐写嵌入特征，作者提出了均匀嵌入策略，试图将修改平均分布到所有系数中，从而最小化失真，导致更低的统计可检测性，提高隐写术的安全性。在UE的思想下，作者设计了两种失真函数，SC-UED和JC-UED，其中JC-UED能够同时兼顾一阶和二阶统计特性，起到很好的均匀嵌入效果。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>图3的数据分布我目前不知道作何解释，论文里说的是使用nsF5得到的数据相对于原图再统计上的变化。可能是我哪里理解不到位吗？这里先占个坑，后续确认理解无误再进行说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了JPEG隐写术中的UED算法。首先介绍了JPEG的统计特性与隐写分析之间的关系，然后介绍了nsF5算法的修改策略，从而引出均匀嵌入（Uniform Embedding）策略的思想并给出了均匀嵌入失真（Uniform Embedding Distortion）函数的公式。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="UED" scheme="http://odinaris.github.io/tags/UED/"/>
    
  </entry>
  
  <entry>
    <title>About Time</title>
    <link href="http://odinaris.github.io/2019/06/30/About-Time/"/>
    <id>http://odinaris.github.io/2019/06/30/About-Time/</id>
    <published>2019-06-30T15:38:54.000Z</published>
    <updated>2019-11-19T02:15:58.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《About Time》，是我最喜欢的一部电影。到现在，已经看了五遍不止，适逢近日倍感孤独，于是今晚又再次打开它，重温主人公给我带来的温暖美好。</p><a id="more"></a><h1 id="First-Meeting"><a href="#First-Meeting" class="headerlink" title="First Meeting"></a>First Meeting</h1><blockquote><p>初初见你，人群中独自美丽。</p></blockquote><p><img src="/images/about-time/01.jpg" alt></p><p>蒂姆与玛丽初次从漆黑的酒吧里出来，第一次见面匆匆留下联系方式之后，女主灿然回眸。</p><h1 id="First-Night"><a href="#First-Night" class="headerlink" title="First Night"></a>First Night</h1><blockquote><p>一次次重温着今晚的我和你，是因为我真的很爱你。</p></blockquote><p><img src="/images/about-time/02.jpg" alt></p><p>蒂姆将玛丽从无聊如地狱的派对中解救出来，两人在餐厅开怀畅聊，之后玛丽忐忑而勇敢地将蒂姆“骗”到了自己家中。</p><h1 id="Wedding-Planning"><a href="#Wedding-Planning" class="headerlink" title="Wedding Planning"></a>Wedding Planning</h1><blockquote><p>我相信婚姻不是坟墓，而是恋人感情的升华。</p></blockquote><p><img src="/images/about-time/03.jpg" alt></p><p>玛丽和蒂姆就婚礼规划上约定蒂姆定好一件事就脱一件衣服。没想到蒂姆确定了伴郎之后又反悔，真是狡猾~玛丽可不能吃亏！</p><h1 id="Our-Wedding"><a href="#Our-Wedding" class="headerlink" title="Our Wedding"></a>Our Wedding</h1><blockquote><p>我希望我的婚礼是这样的：有你，有我，不要许多人，只要你我眼里满满的都是彼此。</p></blockquote><p><img src="/images/about-time/04.jpg" alt></p><p><img src="/images/about-time/05.jpg" alt></p><p>《II Mondo》响起，门缓缓打开，玛丽身着红裙，笑靥如花，款步走来，幸福与爱意洋溢于脸上。</p><p><img src="/images/about-time/06.jpg" alt></p><p>蒂姆与玛丽的婚礼风雨交加，但他们仍然在狂风中亲吻，很是触动。</p><p><img src="/images/about-time/07.jpg" alt></p><blockquote><p>即使天公不作美，但只要是和你，也无风雨也无晴。</p></blockquote><p>玛丽丝毫不在意婚礼上的恶劣天气，反而对今后的生活充满期待，“Fun!”</p><h1 id="True-Love"><a href="#True-Love" class="headerlink" title="True Love"></a>True Love</h1><blockquote><p>真爱，是爱你的一切，真正地关心你的一切。</p></blockquote><p><img src="/images/about-time/08.jpg" alt></p><p>蒂姆与玛丽两人日夜看守在凯蒂床前，直到她能够认识到自己需要做出改变。</p><p>玛丽的笑容，真的很治愈，很美好。</p><h1 id="Past-amp-Future"><a href="#Past-amp-Future" class="headerlink" title="Past &amp; Future"></a>Past &amp; Future</h1><blockquote><p>你的笑，给了我直面过去的勇气。</p></blockquote><p><img src="/images/about-time/09.jpg" alt></p><p>玛丽说要再生一个孩子，这样就可以当只有一个聪明孩子时，剩下两个还可以是快乐的小笨蛋 :)<br>纠结于将逝的父亲与新生的孩子，看到这可爱的笑容，蒂姆怎能反对。</p><h1 id="Time-Never-Stop"><a href="#Time-Never-Stop" class="headerlink" title="Time Never Stop"></a>Time Never Stop</h1><blockquote><p>Thanks, Dad.</p></blockquote><p><img src="/images/about-time/10.jpg" alt></p><p>父亲带蒂姆又回到了小时候，两人一起在海边散步，打水漂。这是他们最后能在一起相处了。都很开心。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><img src="/images/about-time/11.jpg" alt></p><blockquote><p><strong>We’re all travelling through time together every day of our lives. All we can do is do our best to relish this remarkable ride.</strong></p></blockquote><p>电影结束了，我的人生还有很长很长。我很喜欢这部电影，不止是羡慕憧憬里面的爱情，还感谢这部电影对我心灵的治愈。每次看完这部电影，孤独啊，烦躁啊，伤感啊，都会统统滚到一边去。因为它让我知道，这些，都是我的一生。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;《About Time》，是我最喜欢的一部电影。到现在，已经看了五遍不止，适逢近日倍感孤独，于是今晚又再次打开它，重温主人公给我带来的温暖美好。&lt;/p&gt;
    
    </summary>
    
      <category term="人生啊" scheme="http://odinaris.github.io/categories/%E4%BA%BA%E7%94%9F%E5%95%8A/"/>
    
    
      <category term="电影" scheme="http://odinaris.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题优化配置记录</title>
    <link href="http://odinaris.github.io/2019/06/28/hexo%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://odinaris.github.io/2019/06/28/hexo主题优化配置记录/</id>
    <published>2019-06-28T01:31:22.000Z</published>
    <updated>2019-11-19T02:15:41.986Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hexo-customization/hexo.jpg" alt></p><p>最近在网上查询了很多关于如何优化配置Hexo主题的博客，对自己的博客进行了各种各样的探索。猛然发现如果不记录自己做了哪些修改，以后可能都不知道如何怎样关闭/删除/更新。故把自己使用到的配置和参考的博客记录下来。</p><a id="more"></a><h1 id="为next主题的主页文章添加阴影效果"><a href="#为next主题的主页文章添加阴影效果" class="headerlink" title="为next主题的主页文章添加阴影效果"></a>为next主题的主页文章添加阴影效果</h1><p><a href="https://shuyelife.github.io/post/%E2%80%9C%E4%B8%BAnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E2%80%9D/" target="_blank" rel="noopener">为next主题的主页文章添加阴影效果</a></p><hr><h1 id="NexT主题添加搜索功能"><a href="#NexT主题添加搜索功能" class="headerlink" title="NexT主题添加搜索功能"></a>NexT主题添加搜索功能</h1><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-主题添加搜索功能/" target="_blank" rel="noopener">hexo - Next 主题添加搜索功能</a></p><hr><h1 id="修改nexT主题文章页面宽度"><a href="#修改nexT主题文章页面宽度" class="headerlink" title="修改nexT主题文章页面宽度"></a>修改nexT主题文章页面宽度</h1><p><a href="https://ihaoming.top/archives/9a935f57.html" target="_blank" rel="noopener">修改hexo博客next主题文章页面宽度</a></p><hr><h1 id="修改文章背景颜色"><a href="#修改文章背景颜色" class="headerlink" title="修改文章背景颜色"></a>修改文章背景颜色</h1><p><code>themes\next\source\css\_custom\custom.styl</code>下</p><figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="修改文章字体颜色"><a href="#修改文章字体颜色" class="headerlink" title="修改文章字体颜色"></a>修改文章字体颜色</h1><p><code>themes\next\source\css\_custom\custom.styl</code>下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line"><span class="comment">/* 字体颜色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="自定义样式参考"><a href="#自定义样式参考" class="headerlink" title="自定义样式参考"></a>自定义样式参考</h1><p><a href="https://hoodiearon.github.io/note/2018/03-09/55b3a5a.html" target="_blank" rel="noopener">next爬坑深度魔改</a></p><hr><h1 id="首页摘要图片"><a href="#首页摘要图片" class="headerlink" title="首页摘要图片"></a>首页摘要图片</h1><p>在网上查了很多博客，很多都是先通过<code>hexo-asset-image</code>建立跟文章同名文件夹之后，在文件夹里添加图片。</p><p>然后在<code>frontmatter</code>里添加<code>image:url</code>，其中<code>url</code>就是图像的相对路径，文章名+图像名。</p><p>但是我试了并没有效果，查看源码发现<code>src</code>中的图像路径差别很大。于是又试了另一种方法，将图像放到统一的images文件夹中，然后<code>frontmatter</code>里就写成<code>image:/images/imagename.jpg</code>的格式，最终成功了。</p><p>虽然这种方法可以用，但是因为所有文章图片都放在了同一个文件夹，所以相对管理起来更麻烦一些。</p><hr><h1 id="HEXO支持手写流程图"><a href="#HEXO支持手写流程图" class="headerlink" title="HEXO支持手写流程图"></a>HEXO支持手写流程图</h1><p>暂时不打算添加这个功能，因为不需要，不过先在这里记录一下。</p><p><a href="https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html" target="_blank" rel="noopener">如何让你的HEXO博客支持手写流程图？</a></p><hr><h1 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h1><p>昨天查了一些字数统计的博客，因为时间都是18年以前的，之前的方法都失效了。</p><p>今天又查了一些博客，现把目前可行的方法记录如下。</p><p>首先安装<code>hexo-symbols-count-time</code>包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time -save</span><br></pre></td></tr></table></figure><p>然后在博客配置文件<code>_config.yml</code>中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后在nexT配置文件<code>_config.yml</code>中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><p>这样就可以显示出字数统计和预估阅读时长了。但是字数统计不准确，等之后再考虑优化吧~</p><h1 id="Hexo-中-MathJax-的静态显示（svg）"><a href="#Hexo-中-MathJax-的静态显示（svg）" class="headerlink" title="Hexo 中 MathJax 的静态显示（svg）"></a>Hexo 中 MathJax 的静态显示（svg）</h1><p><img src="/images/hexo-customization/hexo-mathjax-svg.jpg" alt></p><p>因为我的博客以后大部分用来记录科研方面的文章，会经常用到数学公式。之前使用的mathjax虽然能够正常显示，但每次都要动态加载，渲染需要好几秒时间，总觉得阅读体验不够流畅，于是在网上找到了下面这篇文章：</p><p><a href="https://io-oi.me/tech/hexo-mathjax-svg.html" target="_blank" rel="noopener">Hexo 中 MathJax 的静态显示（svg）</a></p><p>但是按照这篇文章来更改的时候，发现还是存在一些小问题，所以把完整流程以及需要注意的地方记录如下：</p><p>1）安装</p><p>在博客根目录<code>~/blog/</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g gulp@4.0.2</span><br><span class="line">npm i -S gulp@4.0.2 gulp-mathjax-page</span><br></pre></td></tr></table></figure><p>这里需要注意一下，因为gulp版本是迭代更新的，我现在更新这篇文章时版本已经更新到了4.0.2，而我参考的这篇文章当时是3.9.1，如果用的是旧版本，npm会提示当前版本已弃用，所以这里安装gulp的时候需要根据自己当时的最新版本来更新版本。</p><p>版本查询网址：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="noopener">https://www.npmjs.com/package/gulp</a></p><p>2）新建</p><p>在博客根目录<code>~/blog/</code>下建立<code>js</code>文件<code>gulpfile.js</code>，添加内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">var</span> mathjax = <span class="built_in">require</span>(<span class="string">'gulp-mathjax-page'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp.task('mathjax', function() &#123;</span></span><br><span class="line"><span class="comment">//     gulp.src('./public/**/*.html')</span></span><br><span class="line"><span class="comment">//     .pipe(mathjax(&#123;</span></span><br><span class="line"><span class="comment">//         mjpageConfig: &#123;</span></span><br><span class="line"><span class="comment">//             format: ['TeX'],</span></span><br><span class="line"><span class="comment">//             singleDollars: true,</span></span><br><span class="line"><span class="comment">//             cssInline: false,</span></span><br><span class="line"><span class="comment">//             mhchem: &#123;legacy: true&#125;</span></span><br><span class="line"><span class="comment">//         &#125;,</span></span><br><span class="line"><span class="comment">//         mjnodeConfig: &#123;</span></span><br><span class="line"><span class="comment">//             svg: true,</span></span><br><span class="line"><span class="comment">//             css: false,</span></span><br><span class="line"><span class="comment">//             speakText: false</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;))</span></span><br><span class="line"><span class="comment">//     .pipe(gulp.dest('./public'))</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'mathjax'</span>, done =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(mathjax(&#123;</span><br><span class="line">        mjpageConfig: &#123;</span><br><span class="line">            format: [<span class="string">'TeX'</span>],</span><br><span class="line">            singleDollars: <span class="literal">true</span>,</span><br><span class="line">            cssInline: <span class="literal">false</span>,</span><br><span class="line">            mhchem: &#123;<span class="attr">legacy</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mjnodeConfig: &#123;</span><br><span class="line">            svg: <span class="literal">true</span>,</span><br><span class="line">            css: <span class="literal">false</span>,</span><br><span class="line">            speakText: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里还存在一个问题，上面注释的内容是我参考的文章中给的代码，但是在使用的时候npm会提示错误：</p><p><img src="/images/hexo-customization/error.png" alt></p><p>我把错误提示在Google上搜了一下，在StackOverflow上看到有人也有同样的错误，根据问题下面给出的解决方案，把代码修改成了上面的形式，然后就可以正常使用了。上面代码中注释部分可以删除，这里只是为了展示错误的样例。</p><p>3）样式定制</p><p><code>文件位置：~/blog/themes/next/source/css/_custom/custom.styl</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mjpage__block</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果出现尺寸过大的问题，则加上以下代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.mjpage</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; gulp mathjax &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>本地无法在浏览器直接<code>hexo s</code>查看预览，但可以<code>gulp mathjax</code>后去 public 文件夹下找到相应文件并用浏览器打开预览。当然，这样预览过于麻烦了，所以建议直接用 <a href="https://www.mathjax.org/#demo" target="_blank" rel="noopener">Mathjax 官网的 Live Demo</a> 预览，部署前再用上面这种方法确认一遍即可。</p><p>这里注意一下，每次生成页面时都要输入<code>gulp mathjax</code>,不然下一次渲染还是使用原生的mathjax，又回到了之前的加载速度。</p><h1 id="记一次智障操作"><a href="#记一次智障操作" class="headerlink" title="记一次智障操作"></a>记一次智障操作</h1><p>自从建立整个博客以来，一个问题困扰了我好久，就是为啥我的博客生成的路径跟他们的都！不！一！样！这是我之前的文章路径：</p><p><code>https://odinaris.github.io/undefined/06/28/hexo主题优化配置记录/</code></p><p>于是我就陷入了深深的疑惑，在网上搜索也不得结果。到底为啥我的路径中有<code>undefined</code>啊！</p><p>直到我在<code>_config.yml</code>中发现了这个：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">http://odinaris.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:yeard/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>What the Fuck !?</p><p>我啥时候干的？一脸懵逼好嘛！</p><p>删了那个该死的d之后，现在终于正常了：</p><p><code>https://odinaris.github.io/2019/06/28/hexo主题优化配置记录/</code></p><p>果然是瞎啊。。老年人玩什么博客。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hexo-customization/hexo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最近在网上查询了很多关于如何优化配置Hexo主题的博客，对自己的博客进行了各种各样的探索。猛然发现如果不记录自己做了哪些修改，以后可能都不知道如何怎样关闭/删除/更新。故把自己使用到的配置和参考的博客记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://odinaris.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://odinaris.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之F5、-F5和nsF5</title>
    <link href="http://odinaris.github.io/2019/06/27/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BF5%E3%80%81-F5%E5%92%8CnsF5/"/>
    <id>http://odinaris.github.io/2019/06/27/JPEG隐写术之F5、-F5和nsF5/</id>
    <published>2019-06-26T17:50:27.000Z</published>
    <updated>2019-11-19T02:15:27.306Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先对JPEG隐写术中经典算法F5进行介绍，由于F5存在的缺陷，进而引出对改进算法-F5和nsF5的介绍，主要包括公式原理、<del>源码分析</del>等内容。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Statistically Undetectable JPEG Steganography: Dead Ends, Challenges, and Opportunities</td><td>Fridrich, Jessica, Tomáš Pevný, and Jan Kodovský</td></tr></tbody></table></div><h1 id="F5算法介绍"><a href="#F5算法介绍" class="headerlink" title="F5算法介绍"></a>F5算法介绍</h1><p>F5算法包含两个重要的设计原则，嵌入的特点和矩阵编码。</p><h2 id="嵌入特点"><a href="#嵌入特点" class="headerlink" title="嵌入特点"></a>嵌入特点</h2><p>F5算法的嵌入特点，是只会将DCT系数的绝对值减少1。</p><p>F5只嵌入到非零AC系数中。嵌入之后存在某非零系数变成0的情况，叫做收缩（shrinkage）现象。这种现象只会发生在原始系数值为正负1的系数身上。</p><p>因为解码器只从非零系数中读取秘密信息，如果修改成0之后，接收端无法确认当前读取的0是原始的零系数还是修改之后的零系数。因此嵌入之后如果生成新的0系数，可想而知，这个新的0系数所代表的秘密信息就无法提取出来。换句话说，其代表的特殊含义就泯然众人矣。</p><p>这时，需要跳过当前系数，重新将秘密数据嵌入到下个系数中。</p><h2 id="矩阵编码"><a href="#矩阵编码" class="headerlink" title="矩阵编码"></a>矩阵编码</h2><p>矩阵编码可以使得在一个嵌入修改中嵌入更多的比特，从而增加嵌入效率。</p><p>下面举例说明矩阵编码的概念。</p><p>用$x$表示7个DCT系数的LSB（最低有效位），以列向量表示，即$x_{7\times1}$。</p><p>用<script type="math/tex">m</script>表示3比特秘密信息，也以列向量表示。</p><p>首先生成一个$3\times7$的二元矩阵$H$，其中每一列都是长度为3的非零向量：</p><script type="math/tex; mode=display">H= \left(  \begin{matrix}    1 & 0 & 0 & 1 & 1 & 0 & 1\\    0 & 1 & 0 & 1 & 0 & 1 & 1 \\    0 & 0 & 1 & 0 & 1 & 1 & 1   \end{matrix}  \right)</script><p>嵌入时，首先检查$Hx=m$是否成立。如果等式成立，那么不需要进行任何嵌入修改就可以实现秘密信息嵌入（即$x=y$，$y$即stego矩阵中对应位置的系数的LSB列向量）。秘密信息<script type="math/tex">m</script>可以通过下式提取：</p><script type="math/tex; mode=display">m=Hy</script><p>如果等式不成立，首先要找到$Hx$与$m$中不一致的列，比如第$j$列。然后通过改变$x$中第$j$个比特来嵌如秘密信息$m$。最终生成修改后的系数的LSB列向量，也就是$y$。</p><p>接收者可以通过使用相同的矩阵乘法来正确地从stego图像中提取出秘密信息:</p><script type="math/tex; mode=display">m=Hy</script><p>因此，在这个例子中，通过矩阵编码，可以只造成平均<script type="math/tex">1-1/2^3</script>次修改就可以将3比特信息嵌入到7个DCT系数中。这里的<script type="math/tex">1/2^3</script>是因为当<script type="math/tex">Hx=m</script>时，不需要进行修改就可以嵌入数据，而等式成立的概率正好是1/8。</p><p>矩阵编码方法可以推广到更一般的形式：</p><p><strong>通过造成至多1嵌入修改或者平均<script type="math/tex">1-2^{-p}</script>次修改，来将p比特数据嵌入到<script type="math/tex">2^{p}-1</script>个DCT系数中。</strong></p><p>但事实上，F5的嵌入效率是达不到理想的嵌入效率的。这是因为</p><ul><li>收缩现象的存在需要进行额外的嵌入修改。</li><li>收缩现象增加了嵌入操作对DCT系数直方图造成的影响。</li></ul><p>收缩造成的负面效果可以通过几种方式消除，下面介绍的-F5和nsF5就是针对收缩现象而指定的解决方法。</p><h1 id="F5算法"><a href="#F5算法" class="headerlink" title="-F5算法"></a>-F5算法</h1><p>上文提到，F5的第一个设计原则，是将DCT系数的绝对值减1，这会导致收缩现象的产生。而-F5算法做的就是将减1改为加1，这样收缩现象就能避免，也就可以达到理想中的嵌入效率。</p><p>（-F5的缺点暂时不考虑）</p><h1 id="nsF5算法"><a href="#nsF5算法" class="headerlink" title="nsF5算法"></a>nsF5算法</h1><p>另一种解决方法是使用湿纸编码（Wet paper code）来减弱收缩造成的负面效果。</p><p>湿纸编码的思想是假设载体像一张湿了的纸一样，存在干点（dry point）和湿点（wet point）。湿点区域无法进行任何嵌入修改操作。</p><p>nsF5算法首先将置乱后的DCT系数进行分段之后，将零系数作为湿点，将非零系数作为干点进行湿纸编码。这样接收者只需要用共享的编码矩阵提取信息，而无需关心0的可能产生情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先对JPEG隐写术中经典算法F5进行介绍，由于F5存在的缺陷，进而引出对改进算法-F5和nsF5的介绍，主要包括公式原理、&lt;del&gt;源码分析&lt;/del&gt;等内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="nsF5]" scheme="http://odinaris.github.io/tags/nsF5/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之J-UNIWARD</title>
    <link href="http://odinaris.github.io/2019/06/26/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BJ-UNIWARD/"/>
    <id>http://odinaris.github.io/2019/06/26/JPEG隐写术之J-UNIWARD/</id>
    <published>2019-06-26T14:39:27.000Z</published>
    <updated>2019-11-19T02:15:04.246Z</updated>
    
    <content type="html"><![CDATA[<p>本文对JPEG经典隐写术J-UNIWARD进行介绍，首先介绍方向滤波器组，然后解释失真函数的设计思想，最后介绍UNIWARD的加性近似过程。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Universal distortion function for steganography in an arbitrary domain</td><td>Vojtˇech Holub, Jessica Fridrich and Tomáš Denemark</td></tr><tr><td>Digital Image Steganography Using Universal Distortion</td><td>Vojtˇech Holub and Jessica Fridrich</td></tr></tbody></table></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>近几年来，最成功的隐写术是在嵌入秘密数据的同时最小化一个适合定义的失真函数。而由于一些高效实用的编码存在（能够达到逼近率失真边界的嵌入效果），对于从事隐写术的科研工作者来说，本质上唯一剩下的任务就是设计失真函数。</p><p>这篇paper中提出了一种通用失真设计方案，UNIWARD（UNIversal WAvelet Relative Distortion，通用小波相对失真）。UNIWARD可以适用任何域，如空域（S-UNIWARD），JPEG域（J-UNIWARD）还有基于边信息的JPEG域（SI-UNIWARD）。</p><p>最近的隐写分析技术，如RM（Rich Model，富模型）可以通过使用局部多项式模型来很好地拟合clean edges上的改变，因而可以有效检测出clean edges上的改变。因此嵌入算法需要能够将数据嵌入在纹理或噪声区域，这些区域从任何方向上都不容易被建模，因此难以被检测。</p><p>UNIWARD的嵌入失真是<strong>载体图像的方向滤波器组分解中的系数的相对变化总和</strong>。这种方向性使得嵌入变化区域多集中在那些难以建模在多个方向的区域，如纹理和噪声区域，而避免了光滑区域或者clean edges被修改。</p><h2 id="符号解释"><a href="#符号解释" class="headerlink" title="符号解释"></a>符号解释</h2><div class="table-container"><table><thead><tr><th>Notation</th><th>Expalanation</th></tr></thead><tbody><tr><td><script type="math/tex">\pmb{X}</script></td><td>cover的量化后DCT系数矩阵</td></tr><tr><td><strong><script type="math/tex">\pmb{Y}</script></strong></td><td>stego的量化后DCT系数矩阵</td></tr><tr><td><script type="math/tex">X_{ij}</script></td><td>cover中第$i$行第$j$列的量化后DCT系数值</td></tr><tr><td><script type="math/tex">Y_{ij}</script></td><td>stego中第$i$行第$j$列的量化后DCT系数值</td></tr><tr><td><script type="math/tex">n_1</script></td><td>行数</td></tr><tr><td><script type="math/tex">n_2</script></td><td>列数</td></tr></tbody></table></div><hr><h1 id="方向滤波器组（Directional-filter-bank）"><a href="#方向滤波器组（Directional-filter-bank）" class="headerlink" title="方向滤波器组（Directional filter bank）"></a>方向滤波器组（Directional filter bank）</h1><p>方向滤波器组包括三个线性平移不变滤波器，他们的核用$\pmb{B}=\{\pmb{K}^{(1)},\pmb{K}^{(2)},\pmb{K}^{(3)}\}$表示。</p><p>这三个滤波器通过计算方向残差$\pmb{W}^{(k)}=\pmb{K}^{(k)}\star \pmb{X}$来分别从水平、垂直和对角线方向来评估给定图像$\pmb{X}$的光滑程度，其中$’\star’$表示镜像填充（mirror-padded）卷积操作使得方向残差$\pmb{W}^{(k)}$的尺寸与cover的量化后DCT系数矩阵尺寸一致，都是$n_1\times n_2$。<strong>镜像填充的作用是防止在边界处引入embedding artifacts。</strong></p><p>滤波器组的选择是任意的，而在这里作者根据比对各种滤波器组之后，最终选择了从一维低通（和高通）小波分解滤波器来构建滤波器组的核：</p><script type="math/tex; mode=display">\pmb{K}^{1}=\pmb{h}\cdot\pmb{g}^T,\pmb{K}^{2}=\pmb{g}\cdot\pmb{h}^T,\pmb{K}^{3}=\pmb{g}\cdot\pmb{g}^T.</script><p>这种情况下的滤波器分别对应于二维的LH，HL和HH小波方向高通滤波器，并且残差与$\pmb{X}$的第一级未抽取小波LH，HL和HH方向分解一致。<strong>滤波器只限于小波滤波器组，是因为小波表示是已知的能够为自然场景提供良好的去相关性（decorrelation）和能量紧凑化（energy compactification）</strong>。</p><hr><h1 id="失真函数（Distortion-function）"><a href="#失真函数（Distortion-function）" class="headerlink" title="失真函数（Distortion function）"></a>失真函数（Distortion function）</h1><p>对于JPEG图像来说，计算cover和stego之间的失真，首先要将JPEG文件解压到空域，即此时的$\pmb{X}$和$\pmb{Y}$是对应的空域像素矩阵，而非DCT系数矩阵，失真可表示如下：<br><!--$\mathrm{D}(\pmb{X,Y})=\mathrm{D}(J^{-1}(\pmb{X}),J^{-1}(\pmb{Y}))$--></p><script type="math/tex; mode=display">\mathrm{D}(\pmb{X,Y})=\sum_{k=1}^3 \sum_{u,v} \frac{|W_{uv}^{k}(X)-W_{uv}^{k}(Y)|}{\epsilon+|W_{uv}^{k}(X)|}</script><p>其中$\epsilon$是一个正数标量，用于避免分母为0。从上式看出，分母越大，最终失真也就越小。也就是在cover矩阵中，更大的小波系数发生修改造成更小的失真，而这一般是发生在纹理/噪声区域以及图像边缘部分。而另一方面，如果至少一个小的小波系数发生了较大改变，都会造成很大的失真。因此，在至少一个方向上，上式的设计不鼓励嵌入修改发生在内容相对平滑（平滑也更容易被建模）的区域。</p><hr><h1 id="UNIWARD的加性近似"><a href="#UNIWARD的加性近似" class="headerlink" title="UNIWARD的加性近似"></a>UNIWARD的加性近似</h1><h2 id="为什么要使用加性近似？"><a href="#为什么要使用加性近似？" class="headerlink" title="为什么要使用加性近似？"></a>为什么要使用加性近似？</h2><p>在JPEG域中，当修改一个JPEG系数时，会同时影响一整个$8\times8$的像素块，因此有$23\times 23$大小的小波系数也会受到影响。因此当修改多个邻近的像素或者DCT系数时，造成的嵌入修改发生重叠，相互作用。因此失真$\mathrm{D}$是<strong>非加性</strong>的。</p><p>虽然存在一些使用非加性失真函数的嵌入方法，如Gibbs构造，但使用加性失真更容易进行嵌入。并且在UNIWARD中，相邻的嵌入修改造成的影响过于明显使得Gibbs构造的嵌入效果差强人意。UNIWARD不采用Gibbs构造的进一步解释可参考论文，这里不作过多赘述。</p><p>使用加性近似的显著优点是在全局设计上的便利性。因为嵌入过程可以直接通过使用隐写术中的一个标准工具 - STC码来实现。</p><h2 id="如何定义加性近似？"><a href="#如何定义加性近似？" class="headerlink" title="如何定义加性近似？"></a>如何定义加性近似？</h2><p>任何失真函数$\mathrm{D}(\pmb{X,Y})$都可以用来嵌入到加性近似中，通过使用D来计算修改每个像素值或DCT系数$X_{i,j}$的成本$\rho_{ij}$。</p><p>将$X_{i,j}$修改成$Y_{i,j}$并保持其他系数值不变的代价定义如下：</p><script type="math/tex; mode=display">\rho(\pmb{X},Y_{ij})=D(\pmb{X},\pmb{X}_{\sim ij}Y_{ij})</script><p>其中$\pmb{X}_{\sim ij}Y_{ij}$是只有第$ij$个元素发生改变的$\pmb{X}$。当$\pmb{X}=\pmb{Y}$时，$\rho=0$。</p><p>用$D_A(\pmb{X,Y})$来表示加性近似：</p><script type="math/tex; mode=display">D_A(\pmb{X,Y} )=\sum_{i=1}^{n_1} \sum_{j=1}^{n_2} \rho_{ij} (\pmb{X}, Y_{ij} ) [X_{ij}\neq Y_{ij}]</script><p>其中$[S]$用来表示艾弗森括号，当括号中的状态S为真时，等于1，否则为0。</p><p>由于失真函数$\mathrm{D}(\pmb{X,Y})$中的绝对值存在，表明</p><script type="math/tex; mode=display">\rho_{ij}(\pmb{X},X_{ij}-1)=\rho_{ij}(\pmb{X},X_{ij}+1)</script><p>这就使得UNIWARD可以使用三元嵌入操作，进一步提高嵌入效率。具体的嵌入算法构造可以使用STC码的三元多层版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对JPEG经典隐写术J-UNIWARD进行介绍，首先介绍方向滤波器组，然后解释失真函数的设计思想，最后介绍UNIWARD的加性近似过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="J-UNIWARD]" scheme="http://odinaris.github.io/tags/J-UNIWARD/"/>
    
  </entry>
  
  <entry>
    <title>Latex - IEEEtran模板踩坑日志</title>
    <link href="http://odinaris.github.io/2019/03/15/Latex-IEEEtran%E6%A8%A1%E6%9D%BF%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97/"/>
    <id>http://odinaris.github.io/2019/03/15/Latex-IEEEtran模板踩坑日志/</id>
    <published>2019-03-15T14:31:40.000Z</published>
    <updated>2019-11-19T02:14:35.345Z</updated>
    
    <content type="html"><![CDATA[<p>最近有篇paper需要投稿到TCSVT，所以前几天下载了IEEEtran模板把之前的word版转换成latex版。因为编辑过程中遇到不少困难，故特地记录下来，方便自己以后查阅。</p><a id="more"></a><h2 id="“section-”中单词大小写问题"><a href="#“section-”中单词大小写问题" class="headerlink" title="“section{}”中单词大小写问题"></a>“section{}”中单词大小写问题</h2><p>在IEEEtran这个模板中，section{}部分中的内容默认全部格式化成大写，并且每个单词首字母字号更大一些，排查了一下，这个效果是与下面这段代码有关的，如果不想要大写，这段代码可以注释掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hyphenation&#123;op-tical net-works semi-conduc-tor&#125;</span><br></pre></td></tr></table></figure><h2 id="图例标注位置问题"><a href="#图例标注位置问题" class="headerlink" title="图例标注位置问题"></a>图例标注位置问题</h2><p>图例标注默认是左对齐的，我参考了TCSVT中的几篇文章，发现三篇文章对图例的样式设置都不一样</p><p>。一般来说当然是居中好看一些，由于不知道怎么直接修改位置，于是引用了”caption”包，可以设定图例的格式以及位置，比如可以设置成”Figure.”也可以设置成”Fig.”。但是发现修改之后表格的标注会自动修改。原本表格的caption内容是全部大写的，跟section{}中的内容一样，使用了caption包之后就会失去全部大写的效果。我目前放弃使用了caption包，等到下次编辑时看是否能找到好的解决方案。</p><h2 id="花括号下多行公式左对齐解决办法"><a href="#花括号下多行公式左对齐解决办法" class="headerlink" title="花括号下多行公式左对齐解决办法"></a>花括号下多行公式左对齐解决办法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;\nonumber</span><br><span class="line">\centering</span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;lll&#125;</span><br><span class="line">N\leqslant N_u &amp; \\</span><br><span class="line">\sum_&#123;i=1&#125;^&#123;N&#125;p_i\leqslant N_n  &amp; \\</span><br><span class="line">p_i=2^&#123;j&#125;-1,i\in 1,2,\cdots,N,j\in N^* &amp;</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_22-50-56.png" alt="花括号下多行公式左对齐"></p><h2 id="通栏公式-跨双栏"><a href="#通栏公式-跨双栏" class="headerlink" title="通栏公式(跨双栏)"></a>通栏公式(跨双栏)</h2><p>当论文中公式过长的时候，一栏很难展示的很好，也许可以通过\!调整位置或者通过\begin{small}来缩小公式字体，但过长的公式无论如何微调表现都不尽人意，这时候就需要利用通栏公式了。下图就是我想要得到的通栏公式的效果：</p><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_22-55-48.png" alt="通栏公式"></p><p>为此，查阅了不少博客，最终找到了一种有效的处理办法。附上博客地址：</p><p><a href="https://agnesedong.wordpress.com/2010/01/13/%E5%88%86%E4%BA%AB%E4%B8%80%E5%93%88%EF%BC%8C%E8%B7%A8%E5%8F%8C%E6%A0%8F%E9%95%BF%E5%85%AC%E5%BC%8F%E7%9A%84%E7%BD%AE%E9%A1%B6%E7%BD%AE%E5%BA%95/" target="_blank" rel="noopener">跨双栏长公式的置顶/置底</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure*&#125;</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">    M_&#123;opt&#125;=</span><br><span class="line">    \begin&#123;Bmatrix&#125;</span><br><span class="line">        \begin&#123;aligned&#125;</span><br><span class="line">            &amp; \left \&#123; HC_1\leftrightarrow \left \&#123; HC_2,\cdots ,HC_&#123;1+p_1^*&#125; \right \&#125; \right \&#125;,\\ </span><br><span class="line">            &amp; \left \&#123; HC_&#123;2+p_1^*&#125;\leftrightarrow \left \&#123; HC_&#123;3+p_1^*&#125;,\cdots ,HC_&#123;p_1^*+p_2^*+2&#125; \right \&#125; \right \&#125;,\cdots,\\ </span><br><span class="line">            &amp; \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N&#125;\leftrightarrow \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N+1&#125;,\cdots ,HC_&#123;\sum_&#123;i=1&#125;^&#123;N&#125;p_i^*+N&#125; \right \&#125; \right \&#125;  </span><br><span class="line">        \end&#123;aligned&#125;</span><br><span class="line">    \end&#123;Bmatrix&#125;</span><br><span class="line">    \label&#123;eq6&#125; </span><br><span class="line">\end&#123;equation&#125; </span><br><span class="line">\end&#123;figure*&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是图中双栏公式的实现代码，效果还算可以。</p><h2 id="参考文献的引用"><a href="#参考文献的引用" class="headerlink" title="参考文献的引用"></a>参考文献的引用</h2><p>还记得我第二篇paper在编辑参考文献bib文件的时候，一篇一篇地去Google scholar上查，然后一个属性一个属性的复试粘贴QAQ，想想都是泪，真的蠢。这次从Google scholar上发现可以直接点击BibTex就可以直接复制整段引用信息了，然后粘贴到bib文件里，效率比当时是快不少了。但是这样只能一篇一篇的复制，我不知道怎么批量导入，这个还需要查查资料才行。</p><h2 id="表格内文字自动换行问题"><a href="#表格内文字自动换行问题" class="headerlink" title="表格内文字自动换行问题"></a>表格内文字自动换行问题</h2><p>在写算法步骤时，很多时候是采用表格形式展示的，这时候就要使得文字过长的一行可以自动换行了，查询资料之后，找到一种办法效果挺好，就是限定每列固定长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;[!ht]</span><br><span class="line">\renewcommand\arraystretch&#123;1.3&#125;</span><br><span class="line">\caption&#123;Embedding steps of the proposed scheme.&#125;</span><br><span class="line">\label&#123;tab2&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125;</span><br><span class="line">\toprule</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Input:&#125; Original JPEG bitstream $J$ and secret data.&#125;  \\</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Output:&#125;  Marked JPEG bitstream $J_M$. &#125;  \\ \midrule</span><br><span class="line">\textbf&#123;Step 1.&#125; &amp; Parse the entropy coded data and the DHT segment from $J$.                                                        \\</span><br><span class="line">\textbf&#123;Step 2.&#125; &amp; Count the frequency of RSVs according to the corresponding Huffman codes and sort the RSVs in descending order. \\</span><br><span class="line">\textbf&#123;Step 3.&#125; &amp; Construct the optimal mapping relationship $M_&#123;opt&#125;$ according to the given payload.                                 \\</span><br><span class="line">\textbf&#123;Step 4.&#125; &amp; Replace the original Huffman codes in $J$ with the Huffman codes in the mapping set to embed data.                \\</span><br><span class="line">\textbf&#123;Step 5.&#125; &amp; Modify the RSVs in the DHT segment according to $M_&#123;opt&#125;$, then $J_M$ is generated.                                     \\ \bottomrule</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure><p>得到的效果图如下：</p><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_23-09-54.png" alt="表格文字自动换行"></p><p>我觉得效果还是不错的，这段代码核心就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过指定每列固定长度来使得超过长度文字能够自动换行。</p><h2 id="表格行间距设置问题"><a href="#表格行间距设置问题" class="headerlink" title="表格行间距设置问题"></a>表格行间距设置问题</h2><p>就一行代码，比较简单，在\begin{table}下加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\renewcommand\arraystretch&#123;1.5&#125;</span><br></pre></td></tr></table></figure><p>即可，很实用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有篇paper需要投稿到TCSVT，所以前几天下载了IEEEtran模板把之前的word版转换成latex版。因为编辑过程中遇到不少困难，故特地记录下来，方便自己以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Latex" scheme="http://odinaris.github.io/categories/Latex/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Latex" scheme="http://odinaris.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>The thoughts of Science Research &amp; Software Development</title>
    <link href="http://odinaris.github.io/2017/04/22/The%20thoughts%20of%20Science%20Research%20&amp;%20Software%20Development/"/>
    <id>http://odinaris.github.io/2017/04/22/The thoughts of Science Research &amp; Software Development/</id>
    <published>2017-04-22T05:36:09.000Z</published>
    <updated>2019-11-19T02:11:31.546Z</updated>
    
    <content type="html"><![CDATA[<p>今天殷老师对我昨天发给她的论文初稿作了批复。要修改的内容很多，我也认识到自己论文距离高端会议的论文要求还差得很远。但并不是遥不可及。  </p><blockquote><p>修改后的文档已经发给你 审阅-显示标记即可。与你的前一篇论文相比，有进步，尤其有几个点写得很好，加油！  </p></blockquote><p>看到老师发给我的这句话，当时忙着画流程图的我停下来了，心里是挺开心的，也心生些许感慨。  </p><blockquote><p>大概，自己愿意从事科研的原因是因为老师的这种鼓励吧。  </p></blockquote><p>之所以这么想，是因为之前一直一个人摸爬滚打的学习Android开发，遇到不会的，上网搜索博客，社区，找寻各种答案。虽然基本大部分问题能得到解决，可是有些问题描述不清时，总能耽误一天时间，甚至更久。这种没有他人指引的学习方式，既有优点，也有缺点。与中规中矩的大学课堂授课方式不同，自学方向宽阔，时间灵活，也更容易找到适合自己的学习方式，因此学习成果更高。但缺点是，无人指引时，自己即使愿意发力，也不知道朝什么方向努力，从而自己陷入迷茫焦躁的境地。遇到无法解决的问题时，每次都要从网上花费很多精力时间找寻答案，而有时甚至找不到答案，这个过程很锻炼耐心。自学的人如果能够淡然看待每次让人焦躁不耐烦的过程，这条路就能一直走下去。<br>与做开发不同，跟着老师做科研会让我感觉在成长的过程更轻松一些。当自己提出新想法，老师会鼓励你，和你一起探索想法的可能性；当你论文初稿写出来，老师会逐字逐句帮你审核；对你的进步，她看在眼里并毫不吝言地予以鼓励；对你不明白的知识，她亦会毫无保留的传授给你；当你对前进方向感到迷惑时，她会指引你方向。<br>殷老师是一位真正值得我敬佩的老师，我很幸运，也很感激，能够在大学四年中遇到您。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天殷老师对我昨天发给她的论文初稿作了批复。要修改的内容很多，我也认识到自己论文距离高端会议的论文要求还差得很远。但并不是遥不可及。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改后的文档已经发给你 审阅-显示标记即可。与你的前一篇论文相比，有进步，尤其有几个点写得很好，
      
    
    </summary>
    
      <category term="人生啊" scheme="http://odinaris.github.io/categories/%E4%BA%BA%E7%94%9F%E5%95%8A/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="感悟" scheme="http://odinaris.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="开发" scheme="http://odinaris.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>论文写作中的感想</title>
    <link href="http://odinaris.github.io/2017/04/20/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <id>http://odinaris.github.io/2017/04/20/论文写作中的感想/</id>
    <published>2017-04-19T19:38:48.000Z</published>
    <updated>2019-11-19T02:12:37.214Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文乃笔者在论文写作时产生的些许感想，思虑不周，文笔稚嫩。欢迎读者指正，不甚感激。<br><a id="more"></a></p><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>近日在论文写作过程中，介绍前人文献中所述方案时，发现前人文献对所述方案的介绍中并未提到某个关键部分。笔者由此作出两个猜想：</p><ol><li>关键部分作者可能遗漏，但方案实际可行。</li><li>作者只在理论上阐明了方案，并未真正实现至少一次方案，方案实际并不可行。  </li></ol><p>经过笔者理论上的分析后发现猜想2成立。<br>原因如下：该算法方案若要达到论文中所提效果，需解决此关键环节上的问题。若真正实现了方案，不会遗漏每个关键环节，此环节若需阐明，所占篇幅不少，不可能遗漏。同时，细读方案的过程中，发现作者在方案的理论分析中存在基础性错误。也就是对关键环节未处理造成的错误。如果不将此部分解决，方案不会得到正确结果。</p><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>笔者认为诚实认真是作为一名科研工作者最应必备的品质，若论文避重就轻，不切实际，其作者品质亦实不敢苟同。<br>诚实、严谨是笔者目前作为科研菜鸟的初心，既无法容忍他人论文不实，更应提醒自己不忘初心。<br>不忘初心，方得始终。此句笔者在青协时所听甚多，当时渐倦。今日忆起此句，颇有感触，所言非虚，实应谨记。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;此文乃笔者在论文写作时产生的些许感想，思虑不周，文笔稚嫩。欢迎读者指正，不甚感激。&lt;br&gt;
    
    </summary>
    
      <category term="科研" scheme="http://odinaris.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="科研" scheme="http://odinaris.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="感悟" scheme="http://odinaris.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
