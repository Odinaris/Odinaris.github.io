<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>About My Time.</title>
  
  <subtitle>我欲因之梦吴越，一夜飞度镜湖月。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://odinaris.github.io/"/>
  <updated>2019-07-02T16:54:27.377Z</updated>
  <id>http://odinaris.github.io/</id>
  
  <author>
    <name>YangDu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JPEG隐写术之UERD</title>
    <link href="http://odinaris.github.io/2019/07/02/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BUERD/"/>
    <id>http://odinaris.github.io/2019/07/02/JPEG隐写术之UERD/</id>
    <published>2019-07-02T08:29:09.000Z</published>
    <updated>2019-07-02T16:54:27.377Z</updated>
    
    <content type="html"><![CDATA[<p>本文对JPEG隐写术中的UERD算法进行相关介绍。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Using Statistical Image Model for JPEG Steganography: Uniform Embedding Revisited</td><td>Linjie Guo, Jiangqun Ni, Wenkang Su, Chengpei Tang, and Yun Qing Shi</td></tr></tbody></table></div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>UERD这篇论文主要工作可以概况为以下三点：</p><ul><li>使用了所有的DCT系数（包括DC和零AC系数在内）作为载体元素</li><li>基于DCT块和每个DCT系数的模式来构造失真函数</li><li>计算复杂度可忽略不计，更实用</li></ul><h1 id="对UED的攻讦"><a href="#对UED的攻讦" class="headerlink" title="对UED的攻讦"></a>对UED的攻讦</h1><p>UED存在的问题主要有两点：</p><ol><li><p>对原始的均匀嵌入（UE）策略可以从信息论的视角来理解，即<strong>离散源的最大熵原理</strong>。但是对于自然图像来说，<strong>不同大小的DCT系数可容忍的相对变化是不同的</strong>。就是说，对两种值不同的系数进行相同的修改，造成的影响是不同的。</p></li><li><p>对修改的“均匀扩展”是否真的能够得到最佳的安全性？</p></li></ol><h1 id="广义均匀嵌入策略（Generalized-Uniform-Embedding）"><a href="#广义均匀嵌入策略（Generalized-Uniform-Embedding）" class="headerlink" title="广义均匀嵌入策略（Generalized Uniform Embedding）"></a>广义均匀嵌入策略（Generalized Uniform Embedding）</h1><blockquote><p><strong>UED的核心思想是将嵌入造成的修改均匀扩散到全体DCT系数中，而UERD的核心思想是将“检测能力”均匀扩散到全体系数。</strong></p></blockquote><p>上一篇文章介绍UED时提到了变异系数这个概念。变异系数Cv在一阶二阶统计上都表现出了随系数增大而增大的特性，换句话说，就是对系数的<strong>检测能力随着系数增大会下降</strong>。</p><p>UE中采用的是$1/|x|$这种衡量失真的形式，目的在于使得每种系数被选择到用来修改的<strong>“概率”</strong>一样，以达到均匀嵌入的目的。但实际上，这只是不同大小的系数被选择嵌入的概率是均匀的，而非真正意义上的均匀嵌入。因为不同大小的系数进行同样的修改，检测到的影响是不同的。越大的系数进行修改造成的影响越小。</p><p>因此，更合理的选择策略实要将这种“检测能力”均匀扩散到整个系数空间中。为此，需要控制每种系数的相对变化与变异系数$Cv$成比例就可。这种思想叫做广义均匀嵌入策略（Generalized Uniform Embedding）。</p><h1 id="UERD（Uniform-Embedding-Revisted-Distortion）设计"><a href="#UERD（Uniform-Embedding-Revisted-Distortion）设计" class="headerlink" title="UERD（Uniform Embedding Revisted Distortion）设计"></a>UERD（Uniform Embedding Revisted Distortion）设计</h1><p>实现广义均匀嵌入的一般做法是增加具有更大的CV的系数的嵌入几率。</p><p>因为单单比较系数并不能表示任何统计特性，因此作者研究了系数的位置对于CV的影响。而位置的影响主要包括的是AC模式和DCT块来表示。</p><p><strong>注</strong>：这里对AC模式没有进行解释，从上下文内容来看，我猜测是说AC系数在块中的位置，因为文中提到说模式00指的是DC模式，而DC的位置就是左上角也就是位于(0,0)处。下文中所有提到的AC模式，都默认按照AC系数在DCT块中的位置来理解，如AC模式10就是指位于(1,0)位置上的AC系数值得统计直方图。</p><p>首先，作者探究了不同AC模式的统计特性，统计结果表明，<strong>AC模式所处频率越高（右下角），对应的AC系数中拥有的零系数越多，对应的CV值也越低</strong>。说明这些系数被选择修改的概率越低。</p><p>然后，作者探究了具有不同纹理复杂度的块的统计特性。这里衡量纹理复杂度的方式是根据块中非零系数的个数来评判。非零系数越少，复杂度越低。文中将复杂度分级为如下四类：</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562079670314.png" alt="图1. DCT块纹理复杂度分级情况"></p><p>拿第一类来说明，块中非零AC系数个数在0-8之间时，就被分类为最低的纹理复杂度水平。</p><p>统计结果表明，<strong>DCT块中零AC系数个数越多，也就是纹理复杂度越低，对应的CV值就越低</strong>，这些块被选择来修改的概率越低。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562080724299.png" alt="图2. AC模式10下的DCT系数的CV值分布情况"></p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562081309344.png" alt="图3. AC模式33下的DCT系数的CV值分布情况"></p><p>从图2可以看出，零AC系数的CV值在相同模式下也存在比其他非零AC系数值高的情况。而用图2和图3对比可以看出，低频AC模式下的零系数CV值是高于高频AC模式下的零系数CV值的。</p><p>结合这两种实验数据可以看出，<strong>低频AC模式下的零系数CV值高于高频AC模式下的零系数CV值，甚至高于相同模式下的非零系数CV值</strong>。而高纹理复杂度下得零系数CV值比低纹理复杂度下的要高很多，甚至比低纹理复杂度下的其他非零系数CV值都要高。</p><p>这两种情况都证明了<strong>确实存在有比一些非零AC系数更适合嵌入的零AC系数</strong>。</p><p>基于以上发现，作者定义了均匀嵌入重访失真（Uniform Embedding Revisted Distortion）函数$\rho_{ij}$。</p><p>用$x_{ij}$表示在$(i,j)$位置上的DCT系数，$\rho_{ij}$定义如下：</p><script type="math/tex; mode=display">\rho_{ij}=\rho_{ij,mode}\cdot \rho_{ij,block}</script><p>其中$\rho_{ij,mode}$和$\rho_{ij,block}$分别对应于AC模式和DCT块的失真度量。这两个度量的选择有很多种。作者在论文里将AC模式的失真度量定义为对应位置上的量化步长。而DCT块的失真度量定义为$x_{ij}$所属块以及相邻块的能量函数。 假设$x_{ij}$处在第$mn$块中，那么它的块能量$D_{mn}$定义如下：</p><script type="math/tex; mode=display">D_{mn}=\sum^7_{k=0}\sum^7_{l=0}|x_{kl}|\cdot q_{kl}</script><p>其中$x_{kl}$表示的是块中对应位置上的系数值，并且设$x_{00}=0$来避免DC系数造成的影响，$q_{kl}$就是对应位置上的量化步长。</p><p>最终$\rho_{ij}$就可以表示如下:</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UERD/1562084453236.png" alt="UERD失真计算公式"></p><p>（公式有点复杂，不想写latex公式了，偷个懒，哈哈）</p><p>其中$\hat{D}=\{D_{(m-1)(n-1)},D_{(m-1)n},D_{(m-1)(n+1)},D_{m(n-1)},D_{m(n+1)},D_{(m+1)(n-1)},D_{(m+1)n},D_{(m+1)(n+1)}\}$</p><p>是第$mn$个块的相邻八个块的块能量。</p><p>考虑到DC系数的统计特性与AC系数有很大不同，这里作者启发式地将DC系数的失真定义为相邻的AC系数的均值。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>UERD的介绍到此为止，最近调研文献时又发现了一篇18年的TCSVT，文章是对UERD进行的进一步改进，还是他们课题组的。具体没有细看，等有机会阅读完之后再决定是否介绍那一篇吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对JPEG隐写术中的UERD算法进行相关介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="UERD" scheme="http://odinaris.github.io/tags/UERD/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之UED</title>
    <link href="http://odinaris.github.io/2019/07/01/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BUED/"/>
    <id>http://odinaris.github.io/2019/07/01/JPEG隐写术之UED/</id>
    <published>2019-07-01T13:55:36.000Z</published>
    <updated>2019-07-02T09:06:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了JPEG隐写术中的UED算法。首先介绍了JPEG的统计特性与隐写分析之间的关系，然后介绍了nsF5算法的修改策略，从而引出均匀嵌入（Uniform Embedding）策略的思想并给出了均匀嵌入失真（Uniform Embedding Distortion）函数的公式。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Uniform Embedding for Efficient JPEG Steganography</td><td>Linjie Guo, Jiangqun Ni, and Yun Qing Shi</td></tr></tbody></table></div><h1 id="JPEG统计特征"><a href="#JPEG统计特征" class="headerlink" title="JPEG统计特征"></a>JPEG统计特征</h1><p>隐写分析中通常使用量化后的DCT系数来构建特征集合，用以检测JPEG隐写术。实际上，块DCT系数中的直方图和共生矩阵被广泛使用在隐写分析中。直方图对应的是一阶统计，共生矩阵对应的是二阶统计（可以捕获DCT系数之间的相关性）。</p><p>一旦有秘密信息被嵌入到JPEG图像中，DCT系数的统计就会有一定程度的修改，这就给隐写分析留下了踪迹。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562030760847.png" alt="图1. DCT系数的直方图和共生矩阵"></p><p>图1是JPEG原始DCT系数的直方图和共生矩阵。其中共生矩阵中的X2是X1的相邻系数，移动步长为1。可以看出，绝大部分系数都集中在0以及0附近。</p><p>可以认为DCT系数的一阶统计特征是<strong>类拉普拉斯分布</strong>的，这个事实需要注意。</p><h1 id="nsF5的嵌入变化"><a href="#nsF5的嵌入变化" class="headerlink" title="nsF5的嵌入变化"></a>nsF5的嵌入变化</h1><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562031911495.png" alt="图2. 使用nsF5得到的被修改的DCT系数分布直方图"></p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562032063409.png" alt="图3. nsF5相对于原始直方图的修改统计"></p><p>图2是DCT系数使用nsF5算法进行嵌入之后得到的修改后的直方图，可以看到基本上0系数已经移动到左右两边了。图3是对这些修改的统计，可以看出在0系数以及附近的修改所占比重明显。空间有限，这里就不展示共生矩阵的嵌入变化了，但基本上是与一阶统计特性相似的。</p><h1 id="nsF5是如何修改的？"><a href="#nsF5是如何修改的？" class="headerlink" title="nsF5是如何修改的？"></a>nsF5是如何修改的？</h1><p>想要理解为什么nsF5嵌入修改之后会造成上文所述的变化，就要先了解nsF5的工作流程。</p><p>对于给定载荷<script type="math/tex">\alpha</script>，nsF5的具体工作流程如下：</p><ol><li>根据<script type="math/tex">\alpha</script>计算嵌入效率的理论界限;</li><li>计算需要被修改的系数个数<script type="math/tex">n</script>；</li><li>随机选择<script type="math/tex">n</script>个非零AC系数并将他们的绝对值减1.</li></ol><p>上文提到，DCT系数的分布是类拉普拉斯分布的，而nsF5所采用的随机选择策略，会导致大部分被修改的系数都是绝对值小的系数。也就是图中所展示的，大部分修改后的系数集中在绝对值2以内。</p><h1 id="何为均匀嵌入（Uniform-Embedding）？"><a href="#何为均匀嵌入（Uniform-Embedding）？" class="headerlink" title="何为均匀嵌入（Uniform Embedding）？"></a>何为均匀嵌入（Uniform Embedding）？</h1><p>通过利用DCT系数的统计分布特征（类拉普拉斯分布），大部分隐写分析检测JPEG隐写术都可以获得高准确率。对于JPEG隐写术来说，即使采用一种更为有效的编码策略来使得总的系数修改数降低，嵌入后的修改系数分布特征还是相似的。这样还是会很容易被隐写分析者检测出来。</p><p>这时，均匀嵌入策略就异军突起，走向历史舞台了。</p><p>UE策略试图将对系数的嵌入修改扩展到所有存在的系数中去来最小化每个bin（直方图中，列可以叫做bin）的统计变化。这类似于扩频通信（spread specturm）的思想，关于扩频通信，我学通信的朋友生动地给我手绘了一张图来说明：</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562035927784.png" alt="来自某吊打985的top211的胡傲天的亲笔手绘扩频通信原理"></p><p>这是意识流的解释，懂的自然懂（滑稽）。</p><h1 id="均匀嵌入失真函数（UED）的设计思想"><a href="#均匀嵌入失真函数（UED）的设计思想" class="headerlink" title="均匀嵌入失真函数（UED）的设计思想"></a>均匀嵌入失真函数（UED）的设计思想</h1><p>为了能够完成均匀嵌入，使用到的失真函数必须设计成不同大小的系数都能够以相同的优先级被选择到。这个失真函数就称作是均匀嵌入失真函数（Uniform Embedding Distortion）。</p><p>用x表示具有类拉普拉斯分布特征的DCT系数，那么UED使用到的失真函数应该具有下面这种i形式：</p><script type="math/tex; mode=display">\rho(x)=1/|x|</script><p>即，系数x被选择的概率随着x的绝对值增大而减小，成反比。</p><p><img src="https://odinaris-1259564738.cos.ap-shanghai.myqcloud.com/UED/1562036863430.png" alt="图4. UED的分布曲线"></p><p>图4绘制了上述介绍的分布的大致曲线，a是DCT系数的分布，b就是UED每个系数被选择的概率分布，c就是被选择的系数分布的大致曲线。</p><h1 id="对自然图像模型的参考"><a href="#对自然图像模型的参考" class="headerlink" title="对自然图像模型的参考"></a>对自然图像模型的参考</h1><p>很明显看出，使用UED来设计失真时，对绝对值大的DCT系数的修改数量是高于之前提出的方法的。</p><p>现有的JPEG隐写分析方法一般会利用自然图像模型的优势，即根据量化后DCT系数的一阶和二阶统计特性来进行隐写分析。</p><p>如果某种图像模型可以准确的表示DCT系数的分布状况（我的理解是能够对分布情况提出合理的量化表述），那么对载体进行任何轻微的修改都会被检测出来。</p><p>幸运的是，对于自然图像来说，DCT系数的分布严重依赖图像内容，每种内容不同的图像的分布特征都有明显差别。也就是说自然图像的统计特征没有任何一种图像模型可以准确估计出来。这对于隐写术来说，无疑是件好事。</p><p>为了证明自然图像在一阶和二阶统计上的偏差，作者首先计算直方图$p(x)$的均值$\mu(x)$和标准差$\sigma(x)$。然后用归一化变异系数（coefficient of variation）来定义标准差和均值的比：</p><script type="math/tex; mode=display">Cv(x)=\frac {\sigma(x)} {\mu(x)}</script><p>这里就体现了用相对变化来衡量失真的作用，因为<strong>无论用均值和标准差来独自证明检测能力随系数值的变化，都是不合理的</strong>。</p><p>篇幅限制，这些量随系数绝对值增大的变化这里不作展示，只陈述结果。</p><p>作者发现，$Cv(x)$随着$x$的绝对值增加而增加，这说明随着$x$的绝对值增加，DCT系数直方图偏差严重 ，这句十分不理解，但结合论文中对二阶统计的介绍，是说随着系数增大，更难以去建模统计特征，也就是抗隐写分析的能力更好吧（存疑）。</p><p>根据这个结论，如果使每个$x$的相对修改率与它自身的$Cv$值成比例的话，就可以使得对所有x做出均匀的修改，并且一阶统计特性的统计影响也能最小化。在二阶统计上也观察到了相似的效果。因此，修改一个DCT系数，在统计上的影响依赖于系数本身大小以及和它相邻的系数大小。</p><h1 id="均匀嵌入失真函数的设计"><a href="#均匀嵌入失真函数的设计" class="headerlink" title="均匀嵌入失真函数的设计"></a>均匀嵌入失真函数的设计</h1><ul><li>基于单系数的均匀嵌入失真（SC-UED）</li></ul><p>用$c_{ij}$表示在$(i,j)$位置上的DCT系数，SC-UED可以设计如下：</p><script type="math/tex; mode=display">\rho_{ij}^{SC}=|c_{ij}|^{-1}.</script><p>没错，就是上面提到的失真函数设计思想中的一般形式。 </p><ul><li>基于联合系数的均匀嵌入失真（JC-UED）</li></ul><p>设计更加实用的UED，不知需要考虑到DCT系数自身大小，它的块间和块内相邻的系数都需要被考虑在内。作者认为块内和块间相邻系数有着最强的数值相关性。将多个系数同时考虑在内的失真函数就是基于联合系数的均匀嵌入失真（JC-UED）：</p><script type="math/tex; mode=display">\rho_{ij}^{JC}=\sum_{d_{ia} \in N_{ia}}(|c_{ij}|+|d_{ia}|+a_{ia})^{-1}+\sum_{d_{ir} \in N_{ir}}(|c_{ij}|+|d_{ir}|+a_{ir})^{-1}.</script><p>其中$N_{ia}=\{c_{i+1,j},c_{i-1,j},c_{i,j+1},c_{i,j-1}\}$和$N_{ir}=\{c_{i+8j},c_{i-8,j},c_{i,j+8},c_{i,j-8}\}$分别表示块内相邻系数和块间相邻系数。$a_{ia}$和$a_{ir}$是调节参数，具体值可根据实验确定。</p><h1 id="对UED的总结"><a href="#对UED的总结" class="headerlink" title="对UED的总结"></a>对UED的总结</h1><p>因为以往的JPEG隐写术，如nsF5算法对于DCT系数的修改大都集中在零AC系数附近，这是由DCT系数的类拉普拉斯分布及随机选择策略决定的。为了减少这种明显的隐写嵌入特征，作者提出了均匀嵌入策略，试图将修改平均分布到所有系数中，从而最小化失真，导致更低的统计可检测性，提高隐写术的安全性。在UE的思想下，作者设计了两种失真函数，SC-UED和JC-UED，其中JC-UED能够同时兼顾一阶和二阶统计特性，起到很好的均匀嵌入效果。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>图3的数据分布我目前不知道作何解释，论文里说的是使用nsF5得到的数据相对于原图再统计上的变化。可能是我哪里理解不到位吗？这里先占个坑，后续确认理解无误再进行说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了JPEG隐写术中的UED算法。首先介绍了JPEG的统计特性与隐写分析之间的关系，然后介绍了nsF5算法的修改策略，从而引出均匀嵌入（Uniform Embedding）策略的思想并给出了均匀嵌入失真（Uniform Embedding Distortion）函数的公式。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="UED" scheme="http://odinaris.github.io/tags/UED/"/>
    
  </entry>
  
  <entry>
    <title>About Time</title>
    <link href="http://odinaris.github.io/2019/06/30/About-Time/"/>
    <id>http://odinaris.github.io/2019/06/30/About-Time/</id>
    <published>2019-06-30T15:38:54.000Z</published>
    <updated>2019-06-30T17:41:48.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《About Time》，是我最喜欢的一部电影。到现在，已经看了五遍不止，适逢近日倍感孤独，于是今晚又再次打开它，重温主人公给我带来的温暖美好。</p><a id="more"></a><h1 id="First-Meeting"><a href="#First-Meeting" class="headerlink" title="First Meeting"></a>First Meeting</h1><blockquote><p>初初见你，人群中独自美丽。</p></blockquote><p><img src="/images/about-time/01.jpg" alt></p><p>蒂姆与玛丽初次从漆黑的酒吧里出来，第一次见面匆匆留下联系方式之后，女主灿然回眸。</p><h1 id="First-Night"><a href="#First-Night" class="headerlink" title="First Night"></a>First Night</h1><blockquote><p>一次次重温着今晚的我和你，是因为我真的很爱你。</p></blockquote><p><img src="/images/about-time/02.jpg" alt></p><p>蒂姆将玛丽从无聊如地狱的派对中解救出来，两人在餐厅开怀畅聊，之后玛丽忐忑而勇敢地将蒂姆“骗”到了自己家中。</p><h1 id="Wedding-Planning"><a href="#Wedding-Planning" class="headerlink" title="Wedding Planning"></a>Wedding Planning</h1><blockquote><p>我相信婚姻不是坟墓，而是恋人感情的升华。</p></blockquote><p><img src="/images/about-time/03.jpg" alt></p><p>玛丽和蒂姆就婚礼规划上约定蒂姆定好一件事就脱一件衣服。没想到蒂姆确定了伴郎之后又反悔，真是狡猾~玛丽可不能吃亏！</p><h1 id="Our-Wedding"><a href="#Our-Wedding" class="headerlink" title="Our Wedding"></a>Our Wedding</h1><blockquote><p>我希望我的婚礼是这样的：有你，有我，不要许多人，只要你我眼里满满的都是彼此。</p></blockquote><p><img src="/images/about-time/04.jpg" alt></p><p><img src="/images/about-time/05.jpg" alt></p><p>《II Mondo》响起，门缓缓打开，玛丽身着红裙，笑靥如花，款步走来，幸福与爱意洋溢于脸上。</p><p><img src="/images/about-time/06.jpg" alt></p><p>蒂姆与玛丽的婚礼风雨交加，但他们仍然在狂风中亲吻，很是触动。</p><p><img src="/images/about-time/07.jpg" alt></p><blockquote><p>即使天公不作美，但只要是和你，也无风雨也无晴。</p></blockquote><p>玛丽丝毫不在意婚礼上的恶劣天气，反而对今后的生活充满期待，“Fun!”</p><h1 id="True-Love"><a href="#True-Love" class="headerlink" title="True Love"></a>True Love</h1><blockquote><p>真爱，是爱你的一切，真正地关心你的一切。</p></blockquote><p><img src="/images/about-time/08.jpg" alt></p><p>蒂姆与玛丽两人日夜看守在凯蒂床前，直到她能够认识到自己需要做出改变。</p><p>玛丽的笑容，真的很治愈，很美好。</p><h1 id="Past-amp-Future"><a href="#Past-amp-Future" class="headerlink" title="Past &amp; Future"></a>Past &amp; Future</h1><blockquote><p>你的笑，给了我直面过去的勇气。</p></blockquote><p><img src="/images/about-time/09.jpg" alt></p><p>玛丽说要再生一个孩子，这样就可以当只有一个聪明孩子时，剩下两个还可以是快乐的小笨蛋 :)<br>纠结于将逝的父亲与新生的孩子，看到这可爱的笑容，蒂姆怎能反对。</p><h1 id="Time-Never-Stop"><a href="#Time-Never-Stop" class="headerlink" title="Time Never Stop"></a>Time Never Stop</h1><blockquote><p>Thanks, Dad.</p></blockquote><p><img src="/images/about-time/10.jpg" alt></p><p>父亲带蒂姆又回到了小时候，两人一起在海边散步，打水漂。这是他们最后能在一起相处了。都很开心。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><img src="/images/about-time/11.jpg" alt></p><blockquote><p><strong>We’re all travelling through time together every day of our lives. All we can do is do our best to relish this remarkable ride.</strong></p></blockquote><p>电影结束了，我的人生还有很长很长。我很喜欢这部电影，不止是羡慕憧憬里面的爱情，还感谢这部电影对我心灵的治愈。每次看完这部电影，孤独啊，烦躁啊，伤感啊，都会统统滚到一边去。因为它让我知道，这些，都是我的一生。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;《About Time》，是我最喜欢的一部电影。到现在，已经看了五遍不止，适逢近日倍感孤独，于是今晚又再次打开它，重温主人公给我带来的温暖美好。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://odinaris.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="电影" scheme="http://odinaris.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题优化配置记录</title>
    <link href="http://odinaris.github.io/2019/06/28/hexo%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://odinaris.github.io/2019/06/28/hexo主题优化配置记录/</id>
    <published>2019-06-28T01:31:22.000Z</published>
    <updated>2019-06-30T16:48:29.788Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hexo-customization/hexo.jpg" alt></p><p>最近在网上查询了很多关于如何优化配置Hexo主题的博客，对自己的博客进行了各种各样的探索。猛然发现如果不记录自己做了哪些修改，以后可能都不知道如何怎样关闭/删除/更新。故把自己使用到的配置和参考的博客记录下来。</p><a id="more"></a><h1 id="为next主题的主页文章添加阴影效果"><a href="#为next主题的主页文章添加阴影效果" class="headerlink" title="为next主题的主页文章添加阴影效果"></a>为next主题的主页文章添加阴影效果</h1><p><a href="https://shuyelife.github.io/post/%E2%80%9C%E4%B8%BAnext%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E2%80%9D/" target="_blank" rel="noopener">为next主题的主页文章添加阴影效果</a></p><hr><h1 id="NexT主题添加搜索功能"><a href="#NexT主题添加搜索功能" class="headerlink" title="NexT主题添加搜索功能"></a>NexT主题添加搜索功能</h1><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-主题添加搜索功能/" target="_blank" rel="noopener">hexo - Next 主题添加搜索功能</a></p><hr><h1 id="修改nexT主题文章页面宽度"><a href="#修改nexT主题文章页面宽度" class="headerlink" title="修改nexT主题文章页面宽度"></a>修改nexT主题文章页面宽度</h1><p><a href="https://ihaoming.top/archives/9a935f57.html" target="_blank" rel="noopener">修改hexo博客next主题文章页面宽度</a></p><hr><h1 id="修改文章背景颜色"><a href="#修改文章背景颜色" class="headerlink" title="修改文章背景颜色"></a>修改文章背景颜色</h1><p><code>themes\next\source\css\_custom\custom.styl</code>下</p><figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="修改文章字体颜色"><a href="#修改文章字体颜色" class="headerlink" title="修改文章字体颜色"></a>修改文章字体颜色</h1><p><code>themes\next\source\css\_custom\custom.styl</code>下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line"><span class="comment">/* 字体颜色 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="自定义样式参考"><a href="#自定义样式参考" class="headerlink" title="自定义样式参考"></a>自定义样式参考</h1><p><a href="https://hoodiearon.github.io/note/2018/03-09/55b3a5a.html" target="_blank" rel="noopener">next爬坑深度魔改</a></p><hr><h1 id="首页摘要图片"><a href="#首页摘要图片" class="headerlink" title="首页摘要图片"></a>首页摘要图片</h1><p>在网上查了很多博客，很多都是先通过<code>hexo-asset-image</code>建立跟文章同名文件夹之后，在文件夹里添加图片。</p><p>然后在<code>frontmatter</code>里添加<code>image:url</code>，其中<code>url</code>就是图像的相对路径，文章名+图像名。</p><p>但是我试了并没有效果，查看源码发现<code>src</code>中的图像路径差别很大。于是又试了另一种方法，将图像放到统一的images文件夹中，然后<code>frontmatter</code>里就写成<code>image:/images/imagename.jpg</code>的格式，最终成功了。</p><p>虽然这种方法可以用，但是因为所有文章图片都放在了同一个文件夹，所以相对管理起来更麻烦一些。</p><hr><h1 id="HEXO支持手写流程图"><a href="#HEXO支持手写流程图" class="headerlink" title="HEXO支持手写流程图"></a>HEXO支持手写流程图</h1><p>暂时不打算添加这个功能，因为不需要，不过先在这里记录一下。</p><p><a href="https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html" target="_blank" rel="noopener">如何让你的HEXO博客支持手写流程图？</a></p><hr><h1 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h1><p>昨天查了一些字数统计的博客，因为时间都是18年以前的，之前的方法都失效了。</p><p>今天又查了一些博客，现把目前可行的方法记录如下。</p><p>首先安装<code>hexo-symbols-count-time</code>包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time -save</span><br></pre></td></tr></table></figure><p>然后在博客配置文件<code>_config.yml</code>中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后在nexT配置文件<code>_config.yml</code>中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><p>这样就可以显示出字数统计和预估阅读时长了。但是字数统计不准确，等之后再考虑优化吧~</p><h1 id="Hexo-中-MathJax-的静态显示（svg）"><a href="#Hexo-中-MathJax-的静态显示（svg）" class="headerlink" title="Hexo 中 MathJax 的静态显示（svg）"></a>Hexo 中 MathJax 的静态显示（svg）</h1><p><img src="/images/hexo-customization/hexo-mathjax-svg.jpg" alt></p><p>因为我的博客以后大部分用来记录科研方面的文章，会经常用到数学公式。之前使用的mathjax虽然能够正常显示，但每次都要动态加载，渲染需要好几秒时间，总觉得阅读体验不够流畅，于是在网上找到了下面这篇文章：</p><p><a href="https://io-oi.me/tech/hexo-mathjax-svg.html" target="_blank" rel="noopener">Hexo 中 MathJax 的静态显示（svg）</a></p><p>但是按照这篇文章来更改的时候，发现还是存在一些小问题，所以把完整流程以及需要注意的地方记录如下：</p><p>1）安装</p><p>在博客根目录<code>~/blog/</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g gulp@4.0.2</span><br><span class="line">npm i -S gulp@4.0.2 gulp-mathjax-page</span><br></pre></td></tr></table></figure><p>这里需要注意一下，因为gulp版本是迭代更新的，我现在更新这篇文章时版本已经更新到了4.0.2，而我参考的这篇文章当时是3.9.1，如果用的是旧版本，npm会提示当前版本已弃用，所以这里安装gulp的时候需要根据自己当时的最新版本来更新版本。</p><p>版本查询网址：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="noopener">https://www.npmjs.com/package/gulp</a></p><p>2）新建</p><p>在博客根目录<code>~/blog/</code>下建立<code>js</code>文件<code>gulpfile.js</code>，添加内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">var</span> mathjax = <span class="built_in">require</span>(<span class="string">'gulp-mathjax-page'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp.task('mathjax', function() &#123;</span></span><br><span class="line"><span class="comment">//     gulp.src('./public/**/*.html')</span></span><br><span class="line"><span class="comment">//     .pipe(mathjax(&#123;</span></span><br><span class="line"><span class="comment">//         mjpageConfig: &#123;</span></span><br><span class="line"><span class="comment">//             format: ['TeX'],</span></span><br><span class="line"><span class="comment">//             singleDollars: true,</span></span><br><span class="line"><span class="comment">//             cssInline: false,</span></span><br><span class="line"><span class="comment">//             mhchem: &#123;legacy: true&#125;</span></span><br><span class="line"><span class="comment">//         &#125;,</span></span><br><span class="line"><span class="comment">//         mjnodeConfig: &#123;</span></span><br><span class="line"><span class="comment">//             svg: true,</span></span><br><span class="line"><span class="comment">//             css: false,</span></span><br><span class="line"><span class="comment">//             speakText: false</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;))</span></span><br><span class="line"><span class="comment">//     .pipe(gulp.dest('./public'))</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'mathjax'</span>, done =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(mathjax(&#123;</span><br><span class="line">        mjpageConfig: &#123;</span><br><span class="line">            format: [<span class="string">'TeX'</span>],</span><br><span class="line">            singleDollars: <span class="literal">true</span>,</span><br><span class="line">            cssInline: <span class="literal">false</span>,</span><br><span class="line">            mhchem: &#123;<span class="attr">legacy</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mjnodeConfig: &#123;</span><br><span class="line">            svg: <span class="literal">true</span>,</span><br><span class="line">            css: <span class="literal">false</span>,</span><br><span class="line">            speakText: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里还存在一个问题，上面注释的内容是我参考的文章中给的代码，但是在使用的时候npm会提示错误：</p><p><img src="/images/hexo-customization/error.png" alt></p><p>我把错误提示在Google上搜了一下，在StackOverflow上看到有人也有同样的错误，根据问题下面给出的解决方案，把代码修改成了上面的形式，然后就可以正常使用了。上面代码中注释部分可以删除，这里只是为了展示错误的样例。</p><p>3）样式定制</p><p><code>文件位置：~/blog/themes/next/source/css/_custom/custom.styl</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mjpage__block</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果出现尺寸过大的问题，则加上以下代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.mjpage</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; gulp mathjax &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>本地无法在浏览器直接<code>hexo s</code>查看预览，但可以<code>gulp mathjax</code>后去 public 文件夹下找到相应文件并用浏览器打开预览。当然，这样预览过于麻烦了，所以建议直接用 <a href="https://www.mathjax.org/#demo" target="_blank" rel="noopener">Mathjax 官网的 Live Demo</a> 预览，部署前再用上面这种方法确认一遍即可。</p><p>这里注意一下，每次生成页面时都要输入<code>gulp mathjax</code>,不然下一次渲染还是使用原生的mathjax，又回到了之前的加载速度。</p><h1 id="记一次智障操作"><a href="#记一次智障操作" class="headerlink" title="记一次智障操作"></a>记一次智障操作</h1><p>自从建立整个博客以来，一个问题困扰了我好久，就是为啥我的博客生成的路径跟他们的都！不！一！样！这是我之前的文章路径：</p><p><code>https://odinaris.github.io/undefined/06/28/hexo主题优化配置记录/</code></p><p>于是我就陷入了深深的疑惑，在网上搜索也不得结果。到底为啥我的路径中有<code>undefined</code>啊！</p><p>直到我在<code>_config.yml</code>中发现了这个：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">http://odinaris.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:yeard/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>What the Fuck !?</p><p>我啥时候干的？一脸懵逼好嘛！</p><p>删了那个该死的d之后，现在终于正常了：</p><p><code>https://odinaris.github.io/2019/06/28/hexo主题优化配置记录/</code></p><p>果然是瞎啊。。老年人玩什么博客。。<br>```</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hexo-customization/hexo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最近在网上查询了很多关于如何优化配置Hexo主题的博客，对自己的博客进行了各种各样的探索。猛然发现如果不记录自己做了哪些修改，以后可能都不知道如何怎样关闭/删除/更新。故把自己使用到的配置和参考的博客记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://odinaris.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://odinaris.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之F5、-F5和nsF5</title>
    <link href="http://odinaris.github.io/2019/06/27/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BF5%E3%80%81-F5%E5%92%8CnsF5/"/>
    <id>http://odinaris.github.io/2019/06/27/JPEG隐写术之F5、-F5和nsF5/</id>
    <published>2019-06-26T17:50:27.000Z</published>
    <updated>2019-07-02T08:32:30.450Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先对JPEG隐写术中经典算法F5进行介绍，由于F5存在的缺陷，进而引出对改进算法-F5和nsF5的介绍，主要包括公式原理、<del>源码分析</del>等内容。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Statistically Undetectable JPEG Steganography: Dead Ends, Challenges, and Opportunities</td><td>Fridrich, Jessica, Tomáš Pevný, and Jan Kodovský</td></tr></tbody></table></div><h1 id="F5算法介绍"><a href="#F5算法介绍" class="headerlink" title="F5算法介绍"></a>F5算法介绍</h1><p>F5算法包含两个重要的设计原则，嵌入的特点和矩阵编码。</p><h2 id="嵌入特点"><a href="#嵌入特点" class="headerlink" title="嵌入特点"></a>嵌入特点</h2><p>F5算法的嵌入特点，是只会将DCT系数的绝对值减少1。</p><p>F5只嵌入到非零AC系数中。嵌入之后存在某非零系数变成0的情况，叫做收缩（shrinkage）现象。这种现象只会发生在原始系数值为正负1的系数身上。</p><p>因为解码器只从非零系数中读取秘密信息，如果修改成0之后，接收端无法确认当前读取的0是原始的零系数还是修改之后的零系数。因此嵌入之后如果生成新的0系数，可想而知，这个新的0系数所代表的秘密信息就无法提取出来。换句话说，其代表的特殊含义就泯然众人矣。</p><p>这时，需要跳过当前系数，重新将秘密数据嵌入到下个系数中。</p><h2 id="矩阵编码"><a href="#矩阵编码" class="headerlink" title="矩阵编码"></a>矩阵编码</h2><p>矩阵编码可以使得在一个嵌入修改中嵌入更多的比特，从而增加嵌入效率。</p><p>下面举例说明矩阵编码的概念。</p><p>用$x$表示7个DCT系数的LSB（最低有效位），以列向量表示，即$x_{7\times1}$。</p><p>用<script type="math/tex">m</script>表示3比特秘密信息，也以列向量表示。</p><p>首先生成一个$3\times7$的二元矩阵$H$，其中每一列都是长度为3的非零向量：</p><script type="math/tex; mode=display">H= \left(  \begin{matrix}    1 & 0 & 0 & 1 & 1 & 0 & 1\\    0 & 1 & 0 & 1 & 0 & 1 & 1 \\    0 & 0 & 1 & 0 & 1 & 1 & 1   \end{matrix}  \right)</script><p>嵌入时，首先检查$Hx=m$是否成立。如果等式成立，那么不需要进行任何嵌入修改就可以实现秘密信息嵌入（即$x=y$，$y$即stego矩阵中对应位置的系数的LSB列向量）。秘密信息<script type="math/tex">m</script>可以通过下式提取：</p><script type="math/tex; mode=display">m=Hy</script><p>如果等式不成立，首先要找到$Hx$与$m$中不一致的列，比如第$j$列。然后通过改变$x$中第$j$个比特来嵌如秘密信息$m$。最终生成修改后的系数的LSB列向量，也就是$y$。</p><p>接收者可以通过使用相同的矩阵乘法来正确地从stego图像中提取出秘密信息:</p><script type="math/tex; mode=display">m=Hy</script><p>因此，在这个例子中，通过矩阵编码，可以只造成平均<script type="math/tex">1-1/2^3</script>次修改就可以将3比特信息嵌入到7个DCT系数中。这里的<script type="math/tex">1/2^3</script>是因为当<script type="math/tex">Hx=m</script>时，不需要进行修改就可以嵌入数据，而等式成立的概率正好是1/8。</p><p>矩阵编码方法可以推广到更一般的形式：</p><p><strong>通过造成至多1嵌入修改或者平均<script type="math/tex">1-2^{-p}</script>次修改，来将p比特数据嵌入到<script type="math/tex">2^{p}-1</script>个DCT系数中。</strong></p><p>但事实上，F5的嵌入效率是达不到理想的嵌入效率的。这是因为</p><ul><li>收缩现象的存在需要进行额外的嵌入修改。</li><li>收缩现象增加了嵌入操作对DCT系数直方图造成的影响。</li></ul><p>收缩造成的负面效果可以通过几种方式消除，下面介绍的-F5和nsF5就是针对收缩现象而指定的解决方法。</p><h1 id="F5算法"><a href="#F5算法" class="headerlink" title="-F5算法"></a>-F5算法</h1><p>上文提到，F5的第一个设计原则，是将DCT系数的绝对值减1，这会导致收缩现象的产生。而-F5算法做的就是将减1改为加1，这样收缩现象就能避免，也就可以达到理想中的嵌入效率。</p><p>（-F5的缺点暂时不考虑）</p><h1 id="nsF5算法"><a href="#nsF5算法" class="headerlink" title="nsF5算法"></a>nsF5算法</h1><p>另一种解决方法是使用湿纸编码（Wet paper code）来减弱收缩造成的负面效果。</p><p>湿纸编码的思想是假设载体像一张湿了的纸一样，存在干点（dry point）和湿点（wet point）。湿点区域无法进行任何嵌入修改操作。</p><p>nsF5算法首先将置乱后的DCT系数进行分段之后，将零系数作为湿点，将非零系数作为干点进行湿纸编码。这样接收者只需要用共享的编码矩阵提取信息，而无需关心0的可能产生情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先对JPEG隐写术中经典算法F5进行介绍，由于F5存在的缺陷，进而引出对改进算法-F5和nsF5的介绍，主要包括公式原理、&lt;del&gt;源码分析&lt;/del&gt;等内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="nsF5" scheme="http://odinaris.github.io/tags/nsF5/"/>
    
  </entry>
  
  <entry>
    <title>JPEG隐写术之J-UNIWARD</title>
    <link href="http://odinaris.github.io/2019/06/26/JPEG%E9%9A%90%E5%86%99%E6%9C%AF%E4%B9%8BJ-UNIWARD/"/>
    <id>http://odinaris.github.io/2019/06/26/JPEG隐写术之J-UNIWARD/</id>
    <published>2019-06-26T14:39:27.000Z</published>
    <updated>2019-07-01T13:58:12.021Z</updated>
    
    <content type="html"><![CDATA[<p>本文对JPEG经典隐写术J-UNIWARD进行介绍，首先介绍方向滤波器组，然后解释失真函数的设计思想，最后介绍UNIWARD的加性近似过程。</p><a id="more"></a><h1 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h1><div class="table-container"><table><thead><tr><th>Title</th><th>Authors</th></tr></thead><tbody><tr><td>Universal distortion function for steganography in an arbitrary domain</td><td>Vojtˇech Holub, Jessica Fridrich and Tomáš Denemark</td></tr><tr><td>Digital Image Steganography Using Universal Distortion</td><td>Vojtˇech Holub and Jessica Fridrich</td></tr></tbody></table></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>近几年来，最成功的隐写术是在嵌入秘密数据的同时最小化一个适合定义的失真函数。而由于一些高效实用的编码存在（能够达到逼近率失真边界的嵌入效果），对于从事隐写术的科研工作者来说，本质上唯一剩下的任务就是设计失真函数。</p><p>这篇paper中提出了一种通用失真设计方案，UNIWARD（UNIversal WAvelet Relative Distortion，通用小波相对失真）。UNIWARD可以适用任何域，如空域（S-UNIWARD），JPEG域（J-UNIWARD）还有基于边信息的JPEG域（SI-UNIWARD）。</p><p>最近的隐写分析技术，如RM（Rich Model，富模型）可以通过使用局部多项式模型来很好地拟合clean edges上的改变，因而可以有效检测出clean edges上的改变。因此嵌入算法需要能够将数据嵌入在纹理或噪声区域，这些区域从任何方向上都不容易被建模，因此难以被检测。</p><p>UNIWARD的嵌入失真是<strong>载体图像的方向滤波器组分解中的系数的相对变化总和</strong>。这种方向性使得嵌入变化区域多集中在那些难以建模在多个方向的区域，如纹理和噪声区域，而避免了光滑区域或者clean edges被修改。</p><h2 id="符号解释"><a href="#符号解释" class="headerlink" title="符号解释"></a>符号解释</h2><div class="table-container"><table><thead><tr><th>Notation</th><th>Expalanation</th></tr></thead><tbody><tr><td><script type="math/tex">\pmb{X}</script></td><td>cover的量化后DCT系数矩阵</td></tr><tr><td><strong><script type="math/tex">\pmb{Y}</script></strong></td><td>stego的量化后DCT系数矩阵</td></tr><tr><td><script type="math/tex">X_{ij}</script></td><td>cover中第$i$行第$j$列的量化后DCT系数值</td></tr><tr><td><script type="math/tex">Y_{ij}</script></td><td>stego中第$i$行第$j$列的量化后DCT系数值</td></tr><tr><td><script type="math/tex">n_1</script></td><td>行数</td></tr><tr><td><script type="math/tex">n_2</script></td><td>列数</td></tr></tbody></table></div><hr><h1 id="方向滤波器组（Directional-filter-bank）"><a href="#方向滤波器组（Directional-filter-bank）" class="headerlink" title="方向滤波器组（Directional filter bank）"></a>方向滤波器组（Directional filter bank）</h1><p>方向滤波器组包括三个线性平移不变滤波器，他们的核用$\pmb{B}=\{\pmb{K}^{(1)},\pmb{K}^{(2)},\pmb{K}^{(3)}\}$表示。</p><p>这三个滤波器通过计算方向残差$\pmb{W}^{(k)}=\pmb{K}^{(k)}\star \pmb{X}$来分别从水平、垂直和对角线方向来评估给定图像$\pmb{X}$的光滑程度，其中$’\star’$表示镜像填充（mirror-padded）卷积操作使得方向残差$\pmb{W}^{(k)}$的尺寸与cover的量化后DCT系数矩阵尺寸一致，都是$n_1\times n_2$。<strong>镜像填充的作用是防止在边界处引入embedding artifacts。</strong></p><p>滤波器组的选择是任意的，而在这里作者根据比对各种滤波器组之后，最终选择了从一维低通（和高通）小波分解滤波器来构建滤波器组的核：</p><script type="math/tex; mode=display">\pmb{K}^{1}=\pmb{h}\cdot\pmb{g}^T,\pmb{K}^{2}=\pmb{g}\cdot\pmb{h}^T,\pmb{K}^{3}=\pmb{g}\cdot\pmb{g}^T.</script><p>这种情况下的滤波器分别对应于二维的LH，HL和HH小波方向高通滤波器，并且残差与$\pmb{X}$的第一级未抽取小波LH，HL和HH方向分解一致。<strong>滤波器只限于小波滤波器组，是因为小波表示是已知的能够为自然场景提供良好的去相关性（decorrelation）和能量紧凑化（energy compactification）</strong>。</p><hr><h1 id="失真函数（Distortion-function）"><a href="#失真函数（Distortion-function）" class="headerlink" title="失真函数（Distortion function）"></a>失真函数（Distortion function）</h1><p>对于JPEG图像来说，计算cover和stego之间的失真，首先要将JPEG文件解压到空域，即此时的$\pmb{X}$和$\pmb{Y}$是对应的空域像素矩阵，而非DCT系数矩阵，失真可表示如下：<br><!--$\mathrm{D}(\pmb{X,Y})=\mathrm{D}(J^{-1}(\pmb{X}),J^{-1}(\pmb{Y}))$--></p><script type="math/tex; mode=display">\mathrm{D}(\pmb{X,Y})=\sum_{k=1}^3 \sum_{u,v} \frac{|W_{uv}^{k}(X)-W_{uv}^{k}(Y)|}{\epsilon+|W_{uv}^{k}(X)|}</script><p>其中$\epsilon$是一个正数标量，用于避免分母为0。从上式看出，分母越大，最终失真也就越小。也就是在cover矩阵中，更大的小波系数发生修改造成更小的失真，而这一般是发生在纹理/噪声区域以及图像边缘部分。而另一方面，如果至少一个小的小波系数发生了较大改变，都会造成很大的失真。因此，在至少一个方向上，上式的设计不鼓励嵌入修改发生在内容相对平滑（平滑也更容易被建模）的区域。</p><hr><h1 id="UNIWARD的加性近似"><a href="#UNIWARD的加性近似" class="headerlink" title="UNIWARD的加性近似"></a>UNIWARD的加性近似</h1><h2 id="为什么要使用加性近似？"><a href="#为什么要使用加性近似？" class="headerlink" title="为什么要使用加性近似？"></a>为什么要使用加性近似？</h2><p>在JPEG域中，当修改一个JPEG系数时，会同时影响一整个$8\times8$的像素块，因此有$23\times 23$大小的小波系数也会受到影响。因此当修改多个邻近的像素或者DCT系数时，造成的嵌入修改发生重叠，相互作用。因此失真$\mathrm{D}$是<strong>非加性</strong>的。</p><p>虽然存在一些使用非加性失真函数的嵌入方法，如Gibbs构造，但使用加性失真更容易进行嵌入。并且在UNIWARD中，相邻的嵌入修改造成的影响过于明显使得Gibbs构造的嵌入效果差强人意。UNIWARD不采用Gibbs构造的进一步解释可参考论文，这里不作过多赘述。</p><p>使用加性近似的显著优点是在全局设计上的便利性。因为嵌入过程可以直接通过使用隐写术中的一个标准工具 - STC码来实现。</p><h2 id="如何定义加性近似？"><a href="#如何定义加性近似？" class="headerlink" title="如何定义加性近似？"></a>如何定义加性近似？</h2><p>任何失真函数$\mathrm{D}(\pmb{X,Y})$都可以用来嵌入到加性近似中，通过使用D来计算修改每个像素值或DCT系数$X_{i,j}$的成本$\rho_{ij}$。</p><p>将$X_{i,j}$修改成$Y_{i,j}$并保持其他系数值不变的代价定义如下：</p><script type="math/tex; mode=display">\rho(\pmb{X},Y_{ij})=D(\pmb{X},\pmb{X}_{\sim ij}Y_{ij})</script><p>其中$\pmb{X}_{\sim ij}Y_{ij}$是只有第$ij$个元素发生改变的$\pmb{X}$。当$\pmb{X}=\pmb{Y}$时，$\rho=0$。</p><p>用$D_A(\pmb{X,Y})$来表示加性近似：</p><script type="math/tex; mode=display">D_A(\pmb{X,Y} )=\sum_{i=1}^{n_1} \sum_{j=1}^{n_2} \rho_{ij} (\pmb{X}, Y_{ij} ) [X_{ij}\neq Y_{ij}]</script><p>其中$[S]$用来表示艾弗森括号，当括号中的状态S为真时，等于1，否则为0。</p><p>由于失真函数$\mathrm{D}(\pmb{X,Y})$中的绝对值存在，表明</p><script type="math/tex; mode=display">\rho_{ij}(\pmb{X},X_{ij}-1)=\rho_{ij}(\pmb{X},X_{ij}+1)</script><p>这就使得UNIWARD可以使用三元嵌入操作，进一步提高嵌入效率。具体的嵌入算法构造可以使用STC码的三元多层版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对JPEG经典隐写术J-UNIWARD进行介绍，首先介绍方向滤波器组，然后解释失真函数的设计思想，最后介绍UNIWARD的加性近似过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Steganography" scheme="http://odinaris.github.io/categories/Steganography/"/>
    
    
      <category term="Steganography" scheme="http://odinaris.github.io/tags/Steganography/"/>
    
      <category term="J-UNIWARD" scheme="http://odinaris.github.io/tags/J-UNIWARD/"/>
    
  </entry>
  
  <entry>
    <title>IEEEtran模板踩坑日志</title>
    <link href="http://odinaris.github.io/2019/03/15/IEEEtran%E6%A8%A1%E6%9D%BF%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97/"/>
    <id>http://odinaris.github.io/2019/03/15/IEEEtran模板踩坑日志/</id>
    <published>2019-03-15T14:31:40.000Z</published>
    <updated>2019-06-28T01:12:29.102Z</updated>
    
    <content type="html"><![CDATA[<p>最近有篇paper需要投稿到TCSVT，所以前几天下载了IEEEtran模板把之前的word版转换成latex版。因为编辑过程中遇到不少困难，故特地记录下来，方便自己以后查阅。</p><a id="more"></a><h2 id="“section-”中单词大小写问题"><a href="#“section-”中单词大小写问题" class="headerlink" title="“section{}”中单词大小写问题"></a>“section{}”中单词大小写问题</h2><p>在IEEEtran这个模板中，section{}部分中的内容默认全部格式化成大写，并且每个单词首字母字号更大一些，排查了一下，这个效果是与下面这段代码有关的，如果不想要大写，这段代码可以注释掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hyphenation&#123;op-tical net-works semi-conduc-tor&#125;</span><br></pre></td></tr></table></figure><h2 id="图例标注位置问题"><a href="#图例标注位置问题" class="headerlink" title="图例标注位置问题"></a>图例标注位置问题</h2><p>图例标注默认是左对齐的，我参考了TCSVT中的几篇文章，发现三篇文章对图例的样式设置都不一样</p><p>。一般来说当然是居中好看一些，由于不知道怎么直接修改位置，于是引用了”caption”包，可以设定图例的格式以及位置，比如可以设置成”Figure.”也可以设置成”Fig.”。但是发现修改之后表格的标注会自动修改。原本表格的caption内容是全部大写的，跟section{}中的内容一样，使用了caption包之后就会失去全部大写的效果。我目前放弃使用了caption包，等到下次编辑时看是否能找到好的解决方案。</p><h2 id="花括号下多行公式左对齐解决办法"><a href="#花括号下多行公式左对齐解决办法" class="headerlink" title="花括号下多行公式左对齐解决办法"></a>花括号下多行公式左对齐解决办法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;\nonumber</span><br><span class="line">\centering</span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;lll&#125;</span><br><span class="line">N\leqslant N_u &amp; \\</span><br><span class="line">\sum_&#123;i=1&#125;^&#123;N&#125;p_i\leqslant N_n  &amp; \\</span><br><span class="line">p_i=2^&#123;j&#125;-1,i\in 1,2,\cdots,N,j\in N^* &amp;</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_22-50-56.png" alt="花括号下多行公式左对齐"></p><h2 id="通栏公式-跨双栏"><a href="#通栏公式-跨双栏" class="headerlink" title="通栏公式(跨双栏)"></a>通栏公式(跨双栏)</h2><p>当论文中公式过长的时候，一栏很难展示的很好，也许可以通过\!调整位置或者通过\begin{small}来缩小公式字体，但过长的公式无论如何微调表现都不尽人意，这时候就需要利用通栏公式了。下图就是我想要得到的通栏公式的效果：</p><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_22-55-48.png" alt="通栏公式"></p><p>为此，查阅了不少博客，最终找到了一种有效的处理办法。附上博客地址：</p><p><a href="https://agnesedong.wordpress.com/2010/01/13/%E5%88%86%E4%BA%AB%E4%B8%80%E5%93%88%EF%BC%8C%E8%B7%A8%E5%8F%8C%E6%A0%8F%E9%95%BF%E5%85%AC%E5%BC%8F%E7%9A%84%E7%BD%AE%E9%A1%B6%E7%BD%AE%E5%BA%95/" target="_blank" rel="noopener">跨双栏长公式的置顶/置底</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure*&#125;</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">    M_&#123;opt&#125;=</span><br><span class="line">    \begin&#123;Bmatrix&#125;</span><br><span class="line">        \begin&#123;aligned&#125;</span><br><span class="line">            &amp; \left \&#123; HC_1\leftrightarrow \left \&#123; HC_2,\cdots ,HC_&#123;1+p_1^*&#125; \right \&#125; \right \&#125;,\\ </span><br><span class="line">            &amp; \left \&#123; HC_&#123;2+p_1^*&#125;\leftrightarrow \left \&#123; HC_&#123;3+p_1^*&#125;,\cdots ,HC_&#123;p_1^*+p_2^*+2&#125; \right \&#125; \right \&#125;,\cdots,\\ </span><br><span class="line">            &amp; \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N&#125;\leftrightarrow \left \&#123; HC_&#123;\sum_&#123;i=1&#125;^&#123;N-1&#125;p_i^*+N+1&#125;,\cdots ,HC_&#123;\sum_&#123;i=1&#125;^&#123;N&#125;p_i^*+N&#125; \right \&#125; \right \&#125;  </span><br><span class="line">        \end&#123;aligned&#125;</span><br><span class="line">    \end&#123;Bmatrix&#125;</span><br><span class="line">    \label&#123;eq6&#125; </span><br><span class="line">\end&#123;equation&#125; </span><br><span class="line">\end&#123;figure*&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是图中双栏公式的实现代码，效果还算可以。</p><h2 id="参考文献的引用"><a href="#参考文献的引用" class="headerlink" title="参考文献的引用"></a>参考文献的引用</h2><p>还记得我第二篇paper在编辑参考文献bib文件的时候，一篇一篇地去Google scholar上查，然后一个属性一个属性的复试粘贴QAQ，想想都是泪，真的蠢。这次从Google scholar上发现可以直接点击BibTex就可以直接复制整段引用信息了，然后粘贴到bib文件里，效率比当时是快不少了。但是这样只能一篇一篇的复制，我不知道怎么批量导入，这个还需要查查资料才行。</p><h2 id="表格内文字自动换行问题"><a href="#表格内文字自动换行问题" class="headerlink" title="表格内文字自动换行问题"></a>表格内文字自动换行问题</h2><p>在写算法步骤时，很多时候是采用表格形式展示的，这时候就要使得文字过长的一行可以自动换行了，查询资料之后，找到一种办法效果挺好，就是限定每列固定长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;[!ht]</span><br><span class="line">\renewcommand\arraystretch&#123;1.3&#125;</span><br><span class="line">\caption&#123;Embedding steps of the proposed scheme.&#125;</span><br><span class="line">\label&#123;tab2&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125;</span><br><span class="line">\toprule</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Input:&#125; Original JPEG bitstream $J$ and secret data.&#125;  \\</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;\textbf&#123;Output:&#125;  Marked JPEG bitstream $J_M$. &#125;  \\ \midrule</span><br><span class="line">\textbf&#123;Step 1.&#125; &amp; Parse the entropy coded data and the DHT segment from $J$.                                                        \\</span><br><span class="line">\textbf&#123;Step 2.&#125; &amp; Count the frequency of RSVs according to the corresponding Huffman codes and sort the RSVs in descending order. \\</span><br><span class="line">\textbf&#123;Step 3.&#125; &amp; Construct the optimal mapping relationship $M_&#123;opt&#125;$ according to the given payload.                                 \\</span><br><span class="line">\textbf&#123;Step 4.&#125; &amp; Replace the original Huffman codes in $J$ with the Huffman codes in the mapping set to embed data.                \\</span><br><span class="line">\textbf&#123;Step 5.&#125; &amp; Modify the RSVs in the DHT segment according to $M_&#123;opt&#125;$, then $J_M$ is generated.                                     \\ \bottomrule</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure><p>得到的效果图如下：</p><p><img src="http://poex2tesj.bkt.clouddn.com/Snipaste_2019-03-15_23-09-54.png" alt="表格文字自动换行"></p><p>我觉得效果还是不错的，这段代码核心就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;p&#123;1.1cm&#125;p&#123;6.9cm&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过指定每列固定长度来使得超过长度文字能够自动换行。</p><h2 id="表格行间距设置问题"><a href="#表格行间距设置问题" class="headerlink" title="表格行间距设置问题"></a>表格行间距设置问题</h2><p>就一行代码，比较简单，在\begin{table}下加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\renewcommand\arraystretch&#123;1.5&#125;</span><br></pre></td></tr></table></figure><p>即可，很实用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有篇paper需要投稿到TCSVT，所以前几天下载了IEEEtran模板把之前的word版转换成latex版。因为编辑过程中遇到不少困难，故特地记录下来，方便自己以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Latex" scheme="http://odinaris.github.io/categories/Latex/"/>
    
    
      <category term="Latex" scheme="http://odinaris.github.io/tags/Latex/"/>
    
  </entry>
  
</feed>
